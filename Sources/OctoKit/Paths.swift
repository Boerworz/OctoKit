// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import APIClient
import HTTPHeaders

public enum Paths {}

extension Paths {
    public static var root: Root {
        Root(path: "/")
    }

    public struct Root {
        /// Path: `/`
        public let path: String

        /// GitHub API Root
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var authorizationsURL: String
            public var codeSearchURL: String
            public var commitSearchURL: String
            public var currentUserAuthorizationsHTMLURL: String
            public var currentUserRepositoriesURL: String
            public var currentUserURL: String
            public var emailsURL: String
            public var emojisURL: String
            public var eventsURL: String
            public var feedsURL: String
            public var followersURL: String
            public var followingURL: String
            public var gistsURL: String
            public var hubURL: String
            public var issueSearchURL: String
            public var issuesURL: String
            public var keysURL: String
            public var labelSearchURL: String
            public var notificationsURL: String
            public var organizationRepositoriesURL: String
            public var organizationTeamsURL: String
            public var organizationURL: String
            public var publicGistsURL: String
            public var rateLimitURL: String
            public var repositorySearchURL: String
            public var repositoryURL: String
            public var starredGistsURL: String
            public var starredURL: String
            public var topicSearchURL: String?
            public var userOrganizationsURL: String
            public var userRepositoriesURL: String
            public var userSearchURL: String
            public var userURL: String

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.authorizationsURL = try values.decode(String.self, forKey: "authorizations_url")
                self.codeSearchURL = try values.decode(String.self, forKey: "code_search_url")
                self.commitSearchURL = try values.decode(String.self, forKey: "commit_search_url")
                self.currentUserAuthorizationsHTMLURL = try values.decode(String.self, forKey: "current_user_authorizations_html_url")
                self.currentUserRepositoriesURL = try values.decode(String.self, forKey: "current_user_repositories_url")
                self.currentUserURL = try values.decode(String.self, forKey: "current_user_url")
                self.emailsURL = try values.decode(String.self, forKey: "emails_url")
                self.emojisURL = try values.decode(String.self, forKey: "emojis_url")
                self.eventsURL = try values.decode(String.self, forKey: "events_url")
                self.feedsURL = try values.decode(String.self, forKey: "feeds_url")
                self.followersURL = try values.decode(String.self, forKey: "followers_url")
                self.followingURL = try values.decode(String.self, forKey: "following_url")
                self.gistsURL = try values.decode(String.self, forKey: "gists_url")
                self.hubURL = try values.decode(String.self, forKey: "hub_url")
                self.issueSearchURL = try values.decode(String.self, forKey: "issue_search_url")
                self.issuesURL = try values.decode(String.self, forKey: "issues_url")
                self.keysURL = try values.decode(String.self, forKey: "keys_url")
                self.labelSearchURL = try values.decode(String.self, forKey: "label_search_url")
                self.notificationsURL = try values.decode(String.self, forKey: "notifications_url")
                self.organizationRepositoriesURL = try values.decode(String.self, forKey: "organization_repositories_url")
                self.organizationTeamsURL = try values.decode(String.self, forKey: "organization_teams_url")
                self.organizationURL = try values.decode(String.self, forKey: "organization_url")
                self.publicGistsURL = try values.decode(String.self, forKey: "public_gists_url")
                self.rateLimitURL = try values.decode(String.self, forKey: "rate_limit_url")
                self.repositorySearchURL = try values.decode(String.self, forKey: "repository_search_url")
                self.repositoryURL = try values.decode(String.self, forKey: "repository_url")
                self.starredGistsURL = try values.decode(String.self, forKey: "starred_gists_url")
                self.starredURL = try values.decode(String.self, forKey: "starred_url")
                self.topicSearchURL = try values.decodeIfPresent(String.self, forKey: "topic_search_url")
                self.userOrganizationsURL = try values.decode(String.self, forKey: "user_organizations_url")
                self.userRepositoriesURL = try values.decode(String.self, forKey: "user_repositories_url")
                self.userSearchURL = try values.decode(String.self, forKey: "user_search_url")
                self.userURL = try values.decode(String.self, forKey: "user_url")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(authorizationsURL, forKey: "authorizations_url")
                try values.encode(codeSearchURL, forKey: "code_search_url")
                try values.encode(commitSearchURL, forKey: "commit_search_url")
                try values.encode(currentUserAuthorizationsHTMLURL, forKey: "current_user_authorizations_html_url")
                try values.encode(currentUserRepositoriesURL, forKey: "current_user_repositories_url")
                try values.encode(currentUserURL, forKey: "current_user_url")
                try values.encode(emailsURL, forKey: "emails_url")
                try values.encode(emojisURL, forKey: "emojis_url")
                try values.encode(eventsURL, forKey: "events_url")
                try values.encode(feedsURL, forKey: "feeds_url")
                try values.encode(followersURL, forKey: "followers_url")
                try values.encode(followingURL, forKey: "following_url")
                try values.encode(gistsURL, forKey: "gists_url")
                try values.encode(hubURL, forKey: "hub_url")
                try values.encode(issueSearchURL, forKey: "issue_search_url")
                try values.encode(issuesURL, forKey: "issues_url")
                try values.encode(keysURL, forKey: "keys_url")
                try values.encode(labelSearchURL, forKey: "label_search_url")
                try values.encode(notificationsURL, forKey: "notifications_url")
                try values.encode(organizationRepositoriesURL, forKey: "organization_repositories_url")
                try values.encode(organizationTeamsURL, forKey: "organization_teams_url")
                try values.encode(organizationURL, forKey: "organization_url")
                try values.encode(publicGistsURL, forKey: "public_gists_url")
                try values.encode(rateLimitURL, forKey: "rate_limit_url")
                try values.encode(repositorySearchURL, forKey: "repository_search_url")
                try values.encode(repositoryURL, forKey: "repository_url")
                try values.encode(starredGistsURL, forKey: "starred_gists_url")
                try values.encode(starredURL, forKey: "starred_url")
                try values.encodeIfPresent(topicSearchURL, forKey: "topic_search_url")
                try values.encode(userOrganizationsURL, forKey: "user_organizations_url")
                try values.encode(userRepositoriesURL, forKey: "user_repositories_url")
                try values.encode(userSearchURL, forKey: "user_search_url")
                try values.encode(userURL, forKey: "user_url")
            }
        }
    }
}

extension Paths {
    public static var app: App {
        App(path: "/app")
    }

    public struct App {
        /// Path: `/app`
        public let path: String

        /// Get the authenticated app
        public func get() -> Request<Integration> {
            .get(path)
        }
    }
}

extension Paths {
    public static var appManifests: AppManifests {
        AppManifests(path: "/app-manifests")
    }

    public struct AppManifests {
        /// Path: `/app-manifests`
        public let path: String
    }
}

extension Paths.AppManifests {
    public func code(_ code: String) -> WithCode {
        WithCode(path: path + "/" + code)
    }

    public struct WithCode {
        /// Path: `/app-manifests/{code}`
        public let path: String
    }
}

extension Paths.AppManifests.WithCode {
    public var conversions: Conversions {
        Conversions(path: path + "/conversions")
    }

    public struct Conversions {
        /// Path: `/app-manifests/{code}/conversions`
        public let path: String


    }
}

extension Paths.App {
    public var hook: Hook {
        Hook(path: path + "/hook")
    }

    public struct Hook {
        /// Path: `/app/hook`
        public let path: String
    }
}

extension Paths.App.Hook {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/app/hook/config`
        public let path: String

        /// Get a webhook configuration for an app
        public func get() -> Request<WebhookConfig> {
            .get(path)
        }
    }
}

extension Paths.App.Hook {
    public var deliveries: Deliveries {
        Deliveries(path: path + "/deliveries")
    }

    public struct Deliveries {
        /// Path: `/app/hook/deliveries`
        public let path: String


    }
}

extension Paths.App.Hook.Deliveries {
    public func deliveryID(_ deliveryID: String) -> WithDeliveryID {
        WithDeliveryID(path: path + "/" + deliveryID)
    }

    public struct WithDeliveryID {
        /// Path: `/app/hook/deliveries/{delivery_id}`
        public let path: String

        /// Get a delivery for an app webhook
        public func get() -> Request<HookDelivery> {
            .get(path)
        }
    }
}

extension Paths.App.Hook.Deliveries.WithDeliveryID {
    public var attempts: Attempts {
        Attempts(path: path + "/attempts")
    }

    public struct Attempts {
        /// Path: `/app/hook/deliveries/{delivery_id}/attempts`
        public let path: String


    }
}

extension Paths.App {
    public var installations: Installations {
        Installations(path: path + "/installations")
    }

    public struct Installations {
        /// Path: `/app/installations`
        public let path: String


    }
}

extension Paths.App.Installations {
    public func installationID(_ installationID: String) -> WithInstallationID {
        WithInstallationID(path: path + "/" + installationID)
    }

    public struct WithInstallationID {
        /// Path: `/app/installations/{installation_id}`
        public let path: String

        /// Get an installation for the authenticated app
        public func get() -> Request<Installation> {
            .get(path)
        }

        /// Delete an installation for the authenticated app
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.App.Installations.WithInstallationID {
    public var accessTokens: AccessTokens {
        AccessTokens(path: path + "/access_tokens")
    }

    public struct AccessTokens {
        /// Path: `/app/installations/{installation_id}/access_tokens`
        public let path: String


    }
}

extension Paths.App.Installations.WithInstallationID {
    public var suspended: Suspended {
        Suspended(path: path + "/suspended")
    }

    public struct Suspended {
        /// Path: `/app/installations/{installation_id}/suspended`
        public let path: String

        /// Unsuspend an app installation
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var applications: Applications {
        Applications(path: "/applications")
    }

    public struct Applications {
        /// Path: `/applications`
        public let path: String
    }
}

extension Paths.Applications {
    public var grants: Grants {
        Grants(path: path + "/grants")
    }

    public struct Grants {
        /// Path: `/applications/grants`
        public let path: String


    }
}

extension Paths.Applications.Grants {
    public func grantID(_ grantID: String) -> WithGrantID {
        WithGrantID(path: path + "/" + grantID)
    }

    public struct WithGrantID {
        /// Path: `/applications/grants/{grant_id}`
        public let path: String

        /// Get a single grant
        public func get() -> Request<ApplicationGrant> {
            .get(path)
        }

        /// Delete a grant
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Applications {
    public func clientID(_ clientID: String) -> WithClientID {
        WithClientID(path: path + "/" + clientID)
    }

    public struct WithClientID {
        /// Path: `/applications/{client_id}`
        public let path: String
    }
}

extension Paths.Applications.WithClientID {
    public var grant: Grant {
        Grant(path: path + "/grant")
    }

    public struct Grant {
        /// Path: `/applications/{client_id}/grant`
        public let path: String

        /// Delete an app authorization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Applications.WithClientID {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/applications/{client_id}/token`
        public let path: String

        /// Delete an app token
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Applications.WithClientID.Token {
    public var scoped: Scoped {
        Scoped(path: path + "/scoped")
    }

    public struct Scoped {
        /// Path: `/applications/{client_id}/token/scoped`
        public let path: String


    }
}

extension Paths {
    public static var apps: Apps {
        Apps(path: "/apps")
    }

    public struct Apps {
        /// Path: `/apps`
        public let path: String
    }
}

extension Paths.Apps {
    public func appSlug(_ appSlug: String) -> WithAppSlug {
        WithAppSlug(path: path + "/" + appSlug)
    }

    public struct WithAppSlug {
        /// Path: `/apps/{app_slug}`
        public let path: String

        /// Get an app
        public func get() -> Request<Integration> {
            .get(path)
        }
    }
}

extension Paths {
    public static var authorizations: Authorizations {
        Authorizations(path: "/authorizations")
    }

    public struct Authorizations {
        /// Path: `/authorizations`
        public let path: String


    }
}

extension Paths.Authorizations {
    public var clients: Clients {
        Clients(path: path + "/clients")
    }

    public struct Clients {
        /// Path: `/authorizations/clients`
        public let path: String
    }
}

extension Paths.Authorizations.Clients {
    public func clientID(_ clientID: String) -> WithClientID {
        WithClientID(path: path + "/" + clientID)
    }

    public struct WithClientID {
        /// Path: `/authorizations/clients/{client_id}`
        public let path: String


    }
}

extension Paths.Authorizations.Clients.WithClientID {
    public func fingerprint(_ fingerprint: String) -> WithFingerprint {
        WithFingerprint(path: path + "/" + fingerprint)
    }

    public struct WithFingerprint {
        /// Path: `/authorizations/clients/{client_id}/{fingerprint}`
        public let path: String


    }
}

extension Paths.Authorizations {
    public func authorizationID(_ authorizationID: String) -> WithAuthorizationID {
        WithAuthorizationID(path: path + "/" + authorizationID)
    }

    public struct WithAuthorizationID {
        /// Path: `/authorizations/{authorization_id}`
        public let path: String

        /// Get a single authorization
        public func get() -> Request<Authorization> {
            .get(path)
        }

        /// Delete an authorization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var codesOfConduct: CodesOfConduct {
        CodesOfConduct(path: "/codes_of_conduct")
    }

    public struct CodesOfConduct {
        /// Path: `/codes_of_conduct`
        public let path: String


    }
}

extension Paths.CodesOfConduct {
    public func key(_ key: String) -> WithKey {
        WithKey(path: path + "/" + key)
    }

    public struct WithKey {
        /// Path: `/codes_of_conduct/{key}`
        public let path: String

        /// Get a code of conduct
        public func get() -> Request<CodeOfConduct> {
            .get(path)
        }
    }
}

extension Paths {
    public static var emojis: Emojis {
        Emojis(path: "/emojis")
    }

    public struct Emojis {
        /// Path: `/emojis`
        public let path: String

        /// Get emojis
        public func get() -> Request<[String: String]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var enterprises: Enterprises {
        Enterprises(path: "/enterprises")
    }

    public struct Enterprises {
        /// Path: `/enterprises`
        public let path: String
    }
}

extension Paths.Enterprises {
    public func enterprise(_ enterprise: String) -> WithEnterprise {
        WithEnterprise(path: path + "/" + enterprise)
    }

    public struct WithEnterprise {
        /// Path: `/enterprises/{enterprise}`
        public let path: String
    }
}

extension Paths.Enterprises.WithEnterprise {
    public var actions: Actions {
        Actions(path: path + "/actions")
    }

    public struct Actions {
        /// Path: `/enterprises/{enterprise}/actions`
        public let path: String
    }
}

extension Paths.Enterprises.WithEnterprise.Actions {
    public var permissions: Permissions {
        Permissions(path: path + "/permissions")
    }

    public struct Permissions {
        /// Path: `/enterprises/{enterprise}/actions/permissions`
        public let path: String

        /// Get GitHub Actions permissions for an enterprise
        public func get() -> Request<ActionsEnterprisePermissions> {
            .get(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.Permissions {
    public var organizations: Organizations {
        Organizations(path: path + "/organizations")
    }

    public struct Organizations {
        /// Path: `/enterprises/{enterprise}/actions/permissions/organizations`
        public let path: String

        /// List selected organizations enabled for GitHub Actions in an enterprise
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var organizations: [OctoKit.OrganizationSimple]
            public var totalCount: Double

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.organizations = try values.decode([OctoKit.OrganizationSimple].self, forKey: "organizations")
                self.totalCount = try values.decode(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(organizations, forKey: "organizations")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.Permissions.Organizations {
    public func orgID(_ orgID: String) -> WithOrgID {
        WithOrgID(path: path + "/" + orgID)
    }

    public struct WithOrgID {
        /// Path: `/enterprises/{enterprise}/actions/permissions/organizations/{org_id}`
        public let path: String

        /// Disable a selected organization for GitHub Actions in an enterprise
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.Permissions {
    public var selectedActions: SelectedActions {
        SelectedActions(path: path + "/selected-actions")
    }

    public struct SelectedActions {
        /// Path: `/enterprises/{enterprise}/actions/permissions/selected-actions`
        public let path: String

        /// Get allowed actions for an enterprise
        public func get() -> Request<OctoKit.SelectedActions> {
            .get(path)
        }

        /// Set allowed actions for an enterprise
        public func put(_ body: OctoKit.SelectedActions) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions {
    public var runnerGroups: RunnerGroups {
        RunnerGroups(path: path + "/runner-groups")
    }

    public struct RunnerGroups {
        /// Path: `/enterprises/{enterprise}/actions/runner-groups`
        public let path: String

        /// List self-hosted runner groups for an enterprise
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var runnerGroups: [OctoKit.RunnerGroupsEnterprise]
            public var totalCount: Double

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.runnerGroups = try values.decode([OctoKit.RunnerGroupsEnterprise].self, forKey: "runner_groups")
                self.totalCount = try values.decode(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(runnerGroups, forKey: "runner_groups")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.RunnerGroups {
    public func runnerGroupID(_ runnerGroupID: String) -> WithRunnerGroupID {
        WithRunnerGroupID(path: path + "/" + runnerGroupID)
    }

    public struct WithRunnerGroupID {
        /// Path: `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}`
        public let path: String

        /// Get a self-hosted runner group for an enterprise
        public func get() -> Request<RunnerGroupsEnterprise> {
            .get(path)
        }

        /// Delete a self-hosted runner group from an enterprise
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.RunnerGroups.WithRunnerGroupID {
    public var organizations: Organizations {
        Organizations(path: path + "/organizations")
    }

    public struct Organizations {
        /// Path: `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations`
        public let path: String

        /// List organization access to a self-hosted runner group in an enterprise
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var organizations: [OctoKit.OrganizationSimple]
            public var totalCount: Double

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.organizations = try values.decode([OctoKit.OrganizationSimple].self, forKey: "organizations")
                self.totalCount = try values.decode(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(organizations, forKey: "organizations")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.RunnerGroups.WithRunnerGroupID.Organizations {
    public func orgID(_ orgID: String) -> WithOrgID {
        WithOrgID(path: path + "/" + orgID)
    }

    public struct WithOrgID {
        /// Path: `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}`
        public let path: String

        /// Remove organization access to a self-hosted runner group in an enterprise
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.RunnerGroups.WithRunnerGroupID {
    public var runners: Runners {
        Runners(path: path + "/runners")
    }

    public struct Runners {
        /// Path: `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners`
        public let path: String

        /// List self-hosted runners in a group for an enterprise
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var runners: [OctoKit.Runner]
            public var totalCount: Double

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.runners = try values.decode([OctoKit.Runner].self, forKey: "runners")
                self.totalCount = try values.decode(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(runners, forKey: "runners")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.RunnerGroups.WithRunnerGroupID.Runners {
    public func runnerID(_ runnerID: String) -> WithRunnerID {
        WithRunnerID(path: path + "/" + runnerID)
    }

    public struct WithRunnerID {
        /// Path: `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}`
        public let path: String

        /// Remove a self-hosted runner from a group for an enterprise
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions {
    public var runners: Runners {
        Runners(path: path + "/runners")
    }

    public struct Runners {
        /// Path: `/enterprises/{enterprise}/actions/runners`
        public let path: String

        /// List self-hosted runners for an enterprise
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var runners: [OctoKit.Runner]?
            public var totalCount: Double?

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.runners = try values.decodeIfPresent([OctoKit.Runner].self, forKey: "runners")
                self.totalCount = try values.decodeIfPresent(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(runners, forKey: "runners")
                try values.encodeIfPresent(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Actions.Runners {
    public var downloads: Downloads {
        Downloads(path: path + "/downloads")
    }

    public struct Downloads {
        /// Path: `/enterprises/{enterprise}/actions/runners/downloads`
        public let path: String


    }
}

extension Paths.Enterprises.WithEnterprise.Actions.Runners {
    public var registrationToken: RegistrationToken {
        RegistrationToken(path: path + "/registration-token")
    }

    public struct RegistrationToken {
        /// Path: `/enterprises/{enterprise}/actions/runners/registration-token`
        public let path: String


    }
}

extension Paths.Enterprises.WithEnterprise.Actions.Runners {
    public var removeToken: RemoveToken {
        RemoveToken(path: path + "/remove-token")
    }

    public struct RemoveToken {
        /// Path: `/enterprises/{enterprise}/actions/runners/remove-token`
        public let path: String


    }
}

extension Paths.Enterprises.WithEnterprise.Actions.Runners {
    public func runnerID(_ runnerID: String) -> WithRunnerID {
        WithRunnerID(path: path + "/" + runnerID)
    }

    public struct WithRunnerID {
        /// Path: `/enterprises/{enterprise}/actions/runners/{runner_id}`
        public let path: String

        /// Get a self-hosted runner for an enterprise
        public func get() -> Request<Runner> {
            .get(path)
        }

        /// Delete a self-hosted runner from an enterprise
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise {
    public var auditLog: AuditLog {
        AuditLog(path: path + "/audit-log")
    }

    public struct AuditLog {
        /// Path: `/enterprises/{enterprise}/audit-log`
        public let path: String


    }
}

extension Paths.Enterprises.WithEnterprise {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/enterprises/{enterprise}/settings`
        public let path: String
    }
}

extension Paths.Enterprises.WithEnterprise.Settings {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/enterprises/{enterprise}/settings/billing`
        public let path: String
    }
}

extension Paths.Enterprises.WithEnterprise.Settings.Billing {
    public var actions: Actions {
        Actions(path: path + "/actions")
    }

    public struct Actions {
        /// Path: `/enterprises/{enterprise}/settings/billing/actions`
        public let path: String

        /// Get GitHub Actions billing for an enterprise
        public func get() -> Request<ActionsBillingUsage> {
            .get(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Settings.Billing {
    public var advancedSecurity: AdvancedSecurity {
        AdvancedSecurity(path: path + "/advanced-security")
    }

    public struct AdvancedSecurity {
        /// Path: `/enterprises/{enterprise}/settings/billing/advanced-security`
        public let path: String

        /// Get GitHub Advanced Security active committers for an enterprise
        public func get() -> Request<AdvancedSecurityActiveCommitters> {
            .get(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Settings.Billing {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/enterprises/{enterprise}/settings/billing/packages`
        public let path: String

        /// Get GitHub Packages billing for an enterprise
        public func get() -> Request<PackagesBillingUsage> {
            .get(path)
        }
    }
}

extension Paths.Enterprises.WithEnterprise.Settings.Billing {
    public var sharedStorage: SharedStorage {
        SharedStorage(path: path + "/shared-storage")
    }

    public struct SharedStorage {
        /// Path: `/enterprises/{enterprise}/settings/billing/shared-storage`
        public let path: String

        /// Get shared storage billing for an enterprise
        public func get() -> Request<CombinedBillingUsage> {
            .get(path)
        }
    }
}

extension Paths {
    public static var events: Events {
        Events(path: "/events")
    }

    public struct Events {
        /// Path: `/events`
        public let path: String


    }
}

extension Paths {
    public static var feeds: Feeds {
        Feeds(path: "/feeds")
    }

    public struct Feeds {
        /// Path: `/feeds`
        public let path: String

        /// Get feeds
        public func get() -> Request<Feed> {
            .get(path)
        }
    }
}

extension Paths {
    public static var gists: Gists {
        Gists(path: "/gists")
    }

    public struct Gists {
        /// Path: `/gists`
        public let path: String


    }
}

extension Paths.Gists {
    public var `public`: Public {
        Public(path: path + "/public")
    }

    public struct Public {
        /// Path: `/gists/public`
        public let path: String


    }
}

extension Paths.Gists {
    public var starred: Starred {
        Starred(path: path + "/starred")
    }

    public struct Starred {
        /// Path: `/gists/starred`
        public let path: String


    }
}

extension Paths.Gists {
    public func gistID(_ gistID: String) -> WithGistID {
        WithGistID(path: path + "/" + gistID)
    }

    public struct WithGistID {
        /// Path: `/gists/{gist_id}`
        public let path: String

        /// Get a gist
        public func get() -> Request<GistSimple> {
            .get(path)
        }

        /// Delete a gist
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Gists.WithGistID {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/gists/{gist_id}/comments`
        public let path: String


    }
}

extension Paths.Gists.WithGistID.Comments {
    public func commentID(_ commentID: String) -> WithCommentID {
        WithCommentID(path: path + "/" + commentID)
    }

    public struct WithCommentID {
        /// Path: `/gists/{gist_id}/comments/{comment_id}`
        public let path: String

        /// Get a gist comment
        public func get() -> Request<GistComment> {
            .get(path)
        }

        /// Delete a gist comment
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Gists.WithGistID {
    public var commits: Commits {
        Commits(path: path + "/commits")
    }

    public struct Commits {
        /// Path: `/gists/{gist_id}/commits`
        public let path: String


    }
}

extension Paths.Gists.WithGistID {
    public var forks: Forks {
        Forks(path: path + "/forks")
    }

    public struct Forks {
        /// Path: `/gists/{gist_id}/forks`
        public let path: String


    }
}

extension Paths.Gists.WithGistID {
    public var star: Star {
        Star(path: path + "/star")
    }

    public struct Star {
        /// Path: `/gists/{gist_id}/star`
        public let path: String

        /// Check if a gist is starred
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Unstar a gist
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Gists.WithGistID {
    public func sha(_ sha: String) -> WithSha {
        WithSha(path: path + "/" + sha)
    }

    public struct WithSha {
        /// Path: `/gists/{gist_id}/{sha}`
        public let path: String

        /// Get a gist revision
        public func get() -> Request<GistSimple> {
            .get(path)
        }
    }
}

extension Paths {
    public static var gitignore: Gitignore {
        Gitignore(path: "/gitignore")
    }

    public struct Gitignore {
        /// Path: `/gitignore`
        public let path: String
    }
}

extension Paths.Gitignore {
    public var templates: Templates {
        Templates(path: path + "/templates")
    }

    public struct Templates {
        /// Path: `/gitignore/templates`
        public let path: String


    }
}

extension Paths.Gitignore.Templates {
    public func name(_ name: String) -> WithName {
        WithName(path: path + "/" + name)
    }

    public struct WithName {
        /// Path: `/gitignore/templates/{name}`
        public let path: String

        /// Get a gitignore template
        public func get() -> Request<GitignoreTemplate> {
            .get(path)
        }
    }
}

extension Paths {
    public static var installation: Installation {
        Installation(path: "/installation")
    }

    public struct Installation {
        /// Path: `/installation`
        public let path: String
    }
}

extension Paths.Installation {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/installation/repositories`
        public let path: String

        /// List repositories accessible to the app installation
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var repositories: [OctoKit.Repository]
            /// Example: selected
            public var repositorySelection: String?
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.repositories = try values.decode([OctoKit.Repository].self, forKey: "repositories")
                self.repositorySelection = try values.decodeIfPresent(String.self, forKey: "repository_selection")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(repositories, forKey: "repositories")
                try values.encodeIfPresent(repositorySelection, forKey: "repository_selection")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Installation {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/installation/token`
        public let path: String

        /// Revoke an installation access token
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var issues: Issues {
        Issues(path: "/issues")
    }

    public struct Issues {
        /// Path: `/issues`
        public let path: String


    }
}

extension Paths {
    public static var licenses: Licenses {
        Licenses(path: "/licenses")
    }

    public struct Licenses {
        /// Path: `/licenses`
        public let path: String


    }
}

extension Paths.Licenses {
    public func license(_ license: String) -> WithLicense {
        WithLicense(path: path + "/" + license)
    }

    public struct WithLicense {
        /// Path: `/licenses/{license}`
        public let path: String

        /// Get a license
        public func get() -> Request<License> {
            .get(path)
        }
    }
}

extension Paths {
    public static var markdown: Markdown {
        Markdown(path: "/markdown")
    }

    public struct Markdown {
        /// Path: `/markdown`
        public let path: String


    }
}

extension Paths.Markdown {
    public var raw: Raw {
        Raw(path: path + "/raw")
    }

    public struct Raw {
        /// Path: `/markdown/raw`
        public let path: String


    }
}

extension Paths {
    public static var marketplaceListing: MarketplaceListing {
        MarketplaceListing(path: "/marketplace_listing")
    }

    public struct MarketplaceListing {
        /// Path: `/marketplace_listing`
        public let path: String
    }
}

extension Paths.MarketplaceListing {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/marketplace_listing/accounts`
        public let path: String
    }
}

extension Paths.MarketplaceListing.Accounts {
    public func accountID(_ accountID: String) -> WithAccountID {
        WithAccountID(path: path + "/" + accountID)
    }

    public struct WithAccountID {
        /// Path: `/marketplace_listing/accounts/{account_id}`
        public let path: String

        /// Get a subscription plan for an account
        public func get() -> Request<MarketplacePurchase> {
            .get(path)
        }
    }
}

extension Paths.MarketplaceListing {
    public var plans: Plans {
        Plans(path: path + "/plans")
    }

    public struct Plans {
        /// Path: `/marketplace_listing/plans`
        public let path: String


    }
}

extension Paths.MarketplaceListing.Plans {
    public func planID(_ planID: String) -> WithPlanID {
        WithPlanID(path: path + "/" + planID)
    }

    public struct WithPlanID {
        /// Path: `/marketplace_listing/plans/{plan_id}`
        public let path: String
    }
}

extension Paths.MarketplaceListing.Plans.WithPlanID {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/marketplace_listing/plans/{plan_id}/accounts`
        public let path: String


    }
}

extension Paths.MarketplaceListing {
    public var stubbed: Stubbed {
        Stubbed(path: path + "/stubbed")
    }

    public struct Stubbed {
        /// Path: `/marketplace_listing/stubbed`
        public let path: String
    }
}

extension Paths.MarketplaceListing.Stubbed {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/marketplace_listing/stubbed/accounts`
        public let path: String
    }
}

extension Paths.MarketplaceListing.Stubbed.Accounts {
    public func accountID(_ accountID: String) -> WithAccountID {
        WithAccountID(path: path + "/" + accountID)
    }

    public struct WithAccountID {
        /// Path: `/marketplace_listing/stubbed/accounts/{account_id}`
        public let path: String

        /// Get a subscription plan for an account (stubbed)
        public func get() -> Request<MarketplacePurchase> {
            .get(path)
        }
    }
}

extension Paths.MarketplaceListing.Stubbed {
    public var plans: Plans {
        Plans(path: path + "/plans")
    }

    public struct Plans {
        /// Path: `/marketplace_listing/stubbed/plans`
        public let path: String


    }
}

extension Paths.MarketplaceListing.Stubbed.Plans {
    public func planID(_ planID: String) -> WithPlanID {
        WithPlanID(path: path + "/" + planID)
    }

    public struct WithPlanID {
        /// Path: `/marketplace_listing/stubbed/plans/{plan_id}`
        public let path: String
    }
}

extension Paths.MarketplaceListing.Stubbed.Plans.WithPlanID {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/marketplace_listing/stubbed/plans/{plan_id}/accounts`
        public let path: String


    }
}

extension Paths {
    public static var meta: Meta {
        Meta(path: "/meta")
    }

    public struct Meta {
        /// Path: `/meta`
        public let path: String

        /// Get GitHub meta information
        public func get() -> Request<APIOverview> {
            .get(path)
        }
    }
}

extension Paths {
    public static var networks: Networks {
        Networks(path: "/networks")
    }

    public struct Networks {
        /// Path: `/networks`
        public let path: String
    }
}

extension Paths.Networks {
    public func owner(_ owner: String) -> WithOwner {
        WithOwner(path: path + "/" + owner)
    }

    public struct WithOwner {
        /// Path: `/networks/{owner}`
        public let path: String
    }
}

extension Paths.Networks.WithOwner {
    public func repo(_ repo: String) -> WithRepo {
        WithRepo(path: path + "/" + repo)
    }

    public struct WithRepo {
        /// Path: `/networks/{owner}/{repo}`
        public let path: String
    }
}

extension Paths.Networks.WithOwner.WithRepo {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/networks/{owner}/{repo}/events`
        public let path: String


    }
}

extension Paths {
    public static var notifications: Notifications {
        Notifications(path: "/notifications")
    }

    public struct Notifications {
        /// Path: `/notifications`
        public let path: String


    }
}

extension Paths.Notifications {
    public var threads: Threads {
        Threads(path: path + "/threads")
    }

    public struct Threads {
        /// Path: `/notifications/threads`
        public let path: String
    }
}

extension Paths.Notifications.Threads {
    public func threadID(_ threadID: String) -> WithThreadID {
        WithThreadID(path: path + "/" + threadID)
    }

    public struct WithThreadID {
        /// Path: `/notifications/threads/{thread_id}`
        public let path: String

        /// Get a thread
        public func get() -> Request<Thread> {
            .get(path)
        }
    }
}

extension Paths.Notifications.Threads.WithThreadID {
    public var subscription: Subscription {
        Subscription(path: path + "/subscription")
    }

    public struct Subscription {
        /// Path: `/notifications/threads/{thread_id}/subscription`
        public let path: String

        /// Get a thread subscription for the authenticated user
        public func get() -> Request<ThreadSubscription> {
            .get(path)
        }

        /// Delete a thread subscription
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var octocat: Octocat {
        Octocat(path: "/octocat")
    }

    public struct Octocat {
        /// Path: `/octocat`
        public let path: String


    }
}

extension Paths {
    public static var organizations: Organizations {
        Organizations(path: "/organizations")
    }

    public struct Organizations {
        /// Path: `/organizations`
        public let path: String


    }
}

extension Paths.Organizations {
    public func organizationID(_ organizationID: String) -> WithOrganizationID {
        WithOrganizationID(path: path + "/" + organizationID)
    }

    public struct WithOrganizationID {
        /// Path: `/organizations/{organization_id}`
        public let path: String
    }
}

extension Paths.Organizations.WithOrganizationID {
    public var customRoles: CustomRoles {
        CustomRoles(path: path + "/custom_roles")
    }

    public struct CustomRoles {
        /// Path: `/organizations/{organization_id}/custom_roles`
        public let path: String

        /// List custom repository roles in an organization
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var customRoles: [OctoKit.OrganizationCustomRepositoryRole]?
            /// The number of custom roles in this organization
            public var totalCount: Int?

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.customRoles = try values.decodeIfPresent([OctoKit.OrganizationCustomRepositoryRole].self, forKey: "custom_roles")
                self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(customRoles, forKey: "custom_roles")
                try values.encodeIfPresent(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths {
    public static var orgs: Orgs {
        Orgs(path: "/orgs")
    }

    public struct Orgs {
        /// Path: `/orgs`
        public let path: String
    }
}

extension Paths.Orgs {
    public func org(_ org: String) -> WithOrg {
        WithOrg(path: path + "/" + org)
    }

    public struct WithOrg {
        /// Path: `/orgs/{org}`
        public let path: String

        /// Get an organization
        public func get() -> Request<OrganizationFull> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var actions: Actions {
        Actions(path: path + "/actions")
    }

    public struct Actions {
        /// Path: `/orgs/{org}/actions`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Actions {
    public var permissions: Permissions {
        Permissions(path: path + "/permissions")
    }

    public struct Permissions {
        /// Path: `/orgs/{org}/actions/permissions`
        public let path: String

        /// Get GitHub Actions permissions for an organization
        public func get() -> Request<ActionsOrganizationPermissions> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.Permissions {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/orgs/{org}/actions/permissions/repositories`
        public let path: String

        /// List selected repositories enabled for GitHub Actions in an organization
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var repositories: [OctoKit.Repository]
            public var totalCount: Double

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.repositories = try values.decode([OctoKit.Repository].self, forKey: "repositories")
                self.totalCount = try values.decode(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(repositories, forKey: "repositories")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.Permissions.Repositories {
    public func repositoryID(_ repositoryID: String) -> WithRepositoryID {
        WithRepositoryID(path: path + "/" + repositoryID)
    }

    public struct WithRepositoryID {
        /// Path: `/orgs/{org}/actions/permissions/repositories/{repository_id}`
        public let path: String

        /// Disable a selected repository for GitHub Actions in an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.Permissions {
    public var selectedActions: SelectedActions {
        SelectedActions(path: path + "/selected-actions")
    }

    public struct SelectedActions {
        /// Path: `/orgs/{org}/actions/permissions/selected-actions`
        public let path: String

        /// Get allowed actions for an organization
        public func get() -> Request<OctoKit.SelectedActions> {
            .get(path)
        }

        /// Set allowed actions for an organization
        public func put(_ body: OctoKit.SelectedActions) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions {
    public var runnerGroups: RunnerGroups {
        RunnerGroups(path: path + "/runner-groups")
    }

    public struct RunnerGroups {
        /// Path: `/orgs/{org}/actions/runner-groups`
        public let path: String

        /// List self-hosted runner groups for an organization
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var runnerGroups: [OctoKit.RunnerGroupsOrg]
            public var totalCount: Double

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.runnerGroups = try values.decode([OctoKit.RunnerGroupsOrg].self, forKey: "runner_groups")
                self.totalCount = try values.decode(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(runnerGroups, forKey: "runner_groups")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.RunnerGroups {
    public func runnerGroupID(_ runnerGroupID: String) -> WithRunnerGroupID {
        WithRunnerGroupID(path: path + "/" + runnerGroupID)
    }

    public struct WithRunnerGroupID {
        /// Path: `/orgs/{org}/actions/runner-groups/{runner_group_id}`
        public let path: String

        /// Get a self-hosted runner group for an organization
        public func get() -> Request<RunnerGroupsOrg> {
            .get(path)
        }

        /// Delete a self-hosted runner group from an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.RunnerGroups.WithRunnerGroupID {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories`
        public let path: String

        /// List repository access to a self-hosted runner group in an organization
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var repositories: [OctoKit.MinimalRepository]
            public var totalCount: Double

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.repositories = try values.decode([OctoKit.MinimalRepository].self, forKey: "repositories")
                self.totalCount = try values.decode(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(repositories, forKey: "repositories")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.RunnerGroups.WithRunnerGroupID.Repositories {
    public func repositoryID(_ repositoryID: String) -> WithRepositoryID {
        WithRepositoryID(path: path + "/" + repositoryID)
    }

    public struct WithRepositoryID {
        /// Path: `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}`
        public let path: String

        /// Remove repository access to a self-hosted runner group in an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.RunnerGroups.WithRunnerGroupID {
    public var runners: Runners {
        Runners(path: path + "/runners")
    }

    public struct Runners {
        /// Path: `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners`
        public let path: String

        /// List self-hosted runners in a group for an organization
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var runners: [OctoKit.Runner]
            public var totalCount: Double

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.runners = try values.decode([OctoKit.Runner].self, forKey: "runners")
                self.totalCount = try values.decode(Double.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(runners, forKey: "runners")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.RunnerGroups.WithRunnerGroupID.Runners {
    public func runnerID(_ runnerID: String) -> WithRunnerID {
        WithRunnerID(path: path + "/" + runnerID)
    }

    public struct WithRunnerID {
        /// Path: `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}`
        public let path: String

        /// Remove a self-hosted runner from a group for an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions {
    public var runners: Runners {
        Runners(path: path + "/runners")
    }

    public struct Runners {
        /// Path: `/orgs/{org}/actions/runners`
        public let path: String

        /// List self-hosted runners for an organization
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var runners: [OctoKit.Runner]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.runners = try values.decode([OctoKit.Runner].self, forKey: "runners")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(runners, forKey: "runners")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.Runners {
    public var downloads: Downloads {
        Downloads(path: path + "/downloads")
    }

    public struct Downloads {
        /// Path: `/orgs/{org}/actions/runners/downloads`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Actions.Runners {
    public var registrationToken: RegistrationToken {
        RegistrationToken(path: path + "/registration-token")
    }

    public struct RegistrationToken {
        /// Path: `/orgs/{org}/actions/runners/registration-token`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Actions.Runners {
    public var removeToken: RemoveToken {
        RemoveToken(path: path + "/remove-token")
    }

    public struct RemoveToken {
        /// Path: `/orgs/{org}/actions/runners/remove-token`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Actions.Runners {
    public func runnerID(_ runnerID: String) -> WithRunnerID {
        WithRunnerID(path: path + "/" + runnerID)
    }

    public struct WithRunnerID {
        /// Path: `/orgs/{org}/actions/runners/{runner_id}`
        public let path: String

        /// Get a self-hosted runner for an organization
        public func get() -> Request<Runner> {
            .get(path)
        }

        /// Delete a self-hosted runner from an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions {
    public var secrets: Secrets {
        Secrets(path: path + "/secrets")
    }

    public struct Secrets {
        /// Path: `/orgs/{org}/actions/secrets`
        public let path: String

        /// List organization secrets
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var secrets: [OctoKit.OrganizationActionsSecret]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.secrets = try values.decode([OctoKit.OrganizationActionsSecret].self, forKey: "secrets")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(secrets, forKey: "secrets")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.Secrets {
    public var publicKey: PublicKey {
        PublicKey(path: path + "/public-key")
    }

    public struct PublicKey {
        /// Path: `/orgs/{org}/actions/secrets/public-key`
        public let path: String

        /// Get an organization public key
        public func get() -> Request<ActionsPublicKey> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.Secrets {
    public func secretName(_ secretName: String) -> WithSecretName {
        WithSecretName(path: path + "/" + secretName)
    }

    public struct WithSecretName {
        /// Path: `/orgs/{org}/actions/secrets/{secret_name}`
        public let path: String

        /// Get an organization secret
        public func get() -> Request<OrganizationActionsSecret> {
            .get(path)
        }

        /// Delete an organization secret
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.Secrets.WithSecretName {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/orgs/{org}/actions/secrets/{secret_name}/repositories`
        public let path: String

        /// List selected repositories for an organization secret
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var repositories: [OctoKit.MinimalRepository]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.repositories = try values.decode([OctoKit.MinimalRepository].self, forKey: "repositories")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(repositories, forKey: "repositories")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Orgs.WithOrg.Actions.Secrets.WithSecretName.Repositories {
    public func repositoryID(_ repositoryID: String) -> WithRepositoryID {
        WithRepositoryID(path: path + "/" + repositoryID)
    }

    public struct WithRepositoryID {
        /// Path: `/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}`
        public let path: String

        /// Remove selected repository from an organization secret
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var auditLog: AuditLog {
        AuditLog(path: path + "/audit-log")
    }

    public struct AuditLog {
        /// Path: `/orgs/{org}/audit-log`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var blocks: Blocks {
        Blocks(path: path + "/blocks")
    }

    public struct Blocks {
        /// Path: `/orgs/{org}/blocks`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Blocks {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/orgs/{org}/blocks/{username}`
        public let path: String

        /// Check if a user is blocked by an organization
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Unblock a user from an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var credentialAuthorizations: CredentialAuthorizations {
        CredentialAuthorizations(path: path + "/credential-authorizations")
    }

    public struct CredentialAuthorizations {
        /// Path: `/orgs/{org}/credential-authorizations`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.CredentialAuthorizations {
    public func credentialID(_ credentialID: String) -> WithCredentialID {
        WithCredentialID(path: path + "/" + credentialID)
    }

    public struct WithCredentialID {
        /// Path: `/orgs/{org}/credential-authorizations/{credential_id}`
        public let path: String

        /// Remove a SAML SSO authorization for an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/orgs/{org}/events`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var externalGroup: ExternalGroup {
        ExternalGroup(path: path + "/external-group")
    }

    public struct ExternalGroup {
        /// Path: `/orgs/{org}/external-group`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.ExternalGroup {
    public func groupID(_ groupID: String) -> WithGroupID {
        WithGroupID(path: path + "/" + groupID)
    }

    public struct WithGroupID {
        /// Path: `/orgs/{org}/external-group/{group_id}`
        public let path: String

        /// Get an external group
        public func get() -> Request<OctoKit.ExternalGroup> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var externalGroups: ExternalGroups {
        ExternalGroups(path: path + "/external-groups")
    }

    public struct ExternalGroups {
        /// Path: `/orgs/{org}/external-groups`
        public let path: String

        /// List external groups in an organization
        public func get() -> Request<OctoKit.ExternalGroups> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var failedInvitations: FailedInvitations {
        FailedInvitations(path: path + "/failed_invitations")
    }

    public struct FailedInvitations {
        /// Path: `/orgs/{org}/failed_invitations`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var hooks: Hooks {
        Hooks(path: path + "/hooks")
    }

    public struct Hooks {
        /// Path: `/orgs/{org}/hooks`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Hooks {
    public func hookID(_ hookID: String) -> WithHookID {
        WithHookID(path: path + "/" + hookID)
    }

    public struct WithHookID {
        /// Path: `/orgs/{org}/hooks/{hook_id}`
        public let path: String

        /// Get an organization webhook
        public func get() -> Request<OrgHook> {
            .get(path)
        }

        /// Delete an organization webhook
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Hooks.WithHookID {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/orgs/{org}/hooks/{hook_id}/config`
        public let path: String

        /// Get a webhook configuration for an organization
        public func get() -> Request<WebhookConfig> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Hooks.WithHookID {
    public var deliveries: Deliveries {
        Deliveries(path: path + "/deliveries")
    }

    public struct Deliveries {
        /// Path: `/orgs/{org}/hooks/{hook_id}/deliveries`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Hooks.WithHookID.Deliveries {
    public func deliveryID(_ deliveryID: String) -> WithDeliveryID {
        WithDeliveryID(path: path + "/" + deliveryID)
    }

    public struct WithDeliveryID {
        /// Path: `/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}`
        public let path: String

        /// Get a webhook delivery for an organization webhook
        public func get() -> Request<HookDelivery> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Hooks.WithHookID.Deliveries.WithDeliveryID {
    public var attempts: Attempts {
        Attempts(path: path + "/attempts")
    }

    public struct Attempts {
        /// Path: `/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Hooks.WithHookID {
    public var pings: Pings {
        Pings(path: path + "/pings")
    }

    public struct Pings {
        /// Path: `/orgs/{org}/hooks/{hook_id}/pings`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var installation: Installation {
        Installation(path: path + "/installation")
    }

    public struct Installation {
        /// Path: `/orgs/{org}/installation`
        public let path: String

        /// Get an organization installation for the authenticated app
        public func get() -> Request<OctoKit.Installation> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var installations: Installations {
        Installations(path: path + "/installations")
    }

    public struct Installations {
        /// Path: `/orgs/{org}/installations`
        public let path: String

        /// List app installations for an organization
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var installations: [OctoKit.Installation]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.installations = try values.decode([OctoKit.Installation].self, forKey: "installations")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(installations, forKey: "installations")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var interactionLimits: InteractionLimits {
        InteractionLimits(path: path + "/interaction-limits")
    }

    public struct InteractionLimits {
        /// Path: `/orgs/{org}/interaction-limits`
        public let path: String

        /// Set interaction restrictions for an organization
        public func put(_ body: InteractionLimit) -> Request<InteractionLimitResponse> {
            .put(path, body: body)
        }

        /// Remove interaction restrictions for an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var invitations: Invitations {
        Invitations(path: path + "/invitations")
    }

    public struct Invitations {
        /// Path: `/orgs/{org}/invitations`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Invitations {
    public func invitationID(_ invitationID: String) -> WithInvitationID {
        WithInvitationID(path: path + "/" + invitationID)
    }

    public struct WithInvitationID {
        /// Path: `/orgs/{org}/invitations/{invitation_id}`
        public let path: String

        /// Cancel an organization invitation
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Invitations.WithInvitationID {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/orgs/{org}/invitations/{invitation_id}/teams`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var issues: Issues {
        Issues(path: path + "/issues")
    }

    public struct Issues {
        /// Path: `/orgs/{org}/issues`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/orgs/{org}/members`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Members {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/orgs/{org}/members/{username}`
        public let path: String

        /// Check organization membership for a user
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Remove an organization member
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var memberships: Memberships {
        Memberships(path: path + "/memberships")
    }

    public struct Memberships {
        /// Path: `/orgs/{org}/memberships`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Memberships {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/orgs/{org}/memberships/{username}`
        public let path: String

        /// Get organization membership for a user
        public func get() -> Request<OrgMembership> {
            .get(path)
        }

        /// Remove organization membership for a user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var migrations: Migrations {
        Migrations(path: path + "/migrations")
    }

    public struct Migrations {
        /// Path: `/orgs/{org}/migrations`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Migrations {
    public func migrationID(_ migrationID: String) -> WithMigrationID {
        WithMigrationID(path: path + "/" + migrationID)
    }

    public struct WithMigrationID {
        /// Path: `/orgs/{org}/migrations/{migration_id}`
        public let path: String

        /// Get an organization migration status
        public func get() -> Request<Migration> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Migrations.WithMigrationID {
    public var archive: Archive {
        Archive(path: path + "/archive")
    }

    public struct Archive {
        /// Path: `/orgs/{org}/migrations/{migration_id}/archive`
        public let path: String

        /// Download an organization migration archive
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Delete an organization migration archive
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Migrations.WithMigrationID {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/orgs/{org}/migrations/{migration_id}/repos`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Migrations.WithMigrationID.Repos {
    public func repoName(_ repoName: String) -> WithRepoName {
        WithRepoName(path: path + "/" + repoName)
    }

    public struct WithRepoName {
        /// Path: `/orgs/{org}/migrations/{migration_id}/repos/{repo_name}`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Migrations.WithMigrationID.Repos.WithRepoName {
    public var lock: Lock {
        Lock(path: path + "/lock")
    }

    public struct Lock {
        /// Path: `/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock`
        public let path: String

        /// Unlock an organization repository
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Migrations.WithMigrationID {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/orgs/{org}/migrations/{migration_id}/repositories`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var outsideCollaborators: OutsideCollaborators {
        OutsideCollaborators(path: path + "/outside_collaborators")
    }

    public struct OutsideCollaborators {
        /// Path: `/orgs/{org}/outside_collaborators`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.OutsideCollaborators {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/orgs/{org}/outside_collaborators/{username}`
        public let path: String

        /// Remove outside collaborator from an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/orgs/{org}/packages`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Packages {
    public func packageType(_ packageType: String) -> WithPackageType {
        WithPackageType(path: path + "/" + packageType)
    }

    public struct WithPackageType {
        /// Path: `/orgs/{org}/packages/{package_type}`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Packages.WithPackageType {
    public func packageName(_ packageName: String) -> WithPackageName {
        WithPackageName(path: path + "/" + packageName)
    }

    public struct WithPackageName {
        /// Path: `/orgs/{org}/packages/{package_type}/{package_name}`
        public let path: String

        /// Get a package for an organization
        public func get() -> Request<Package> {
            .get(path)
        }

        /// Delete a package for an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Packages.WithPackageType.WithPackageName {
    public var restore: Restore {
        Restore(path: path + "/restore")
    }

    public struct Restore {
        /// Path: `/orgs/{org}/packages/{package_type}/{package_name}/restore`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Packages.WithPackageType.WithPackageName {
    public var versions: Versions {
        Versions(path: path + "/versions")
    }

    public struct Versions {
        /// Path: `/orgs/{org}/packages/{package_type}/{package_name}/versions`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Packages.WithPackageType.WithPackageName.Versions {
    public func packageVersionID(_ packageVersionID: String) -> WithPackageVersionID {
        WithPackageVersionID(path: path + "/" + packageVersionID)
    }

    public struct WithPackageVersionID {
        /// Path: `/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}`
        public let path: String

        /// Get a package version for an organization
        public func get() -> Request<PackageVersion> {
            .get(path)
        }

        /// Delete package version for an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Packages.WithPackageType.WithPackageName.Versions.WithPackageVersionID {
    public var restore: Restore {
        Restore(path: path + "/restore")
    }

    public struct Restore {
        /// Path: `/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var projects: Projects {
        Projects(path: path + "/projects")
    }

    public struct Projects {
        /// Path: `/orgs/{org}/projects`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var publicMembers: PublicMembers {
        PublicMembers(path: path + "/public_members")
    }

    public struct PublicMembers {
        /// Path: `/orgs/{org}/public_members`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.PublicMembers {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/orgs/{org}/public_members/{username}`
        public let path: String

        /// Check public organization membership for a user
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Remove public organization membership for the authenticated user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/orgs/{org}/repos`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var secretScanning: SecretScanning {
        SecretScanning(path: path + "/secret-scanning")
    }

    public struct SecretScanning {
        /// Path: `/orgs/{org}/secret-scanning`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.SecretScanning {
    public var alerts: Alerts {
        Alerts(path: path + "/alerts")
    }

    public struct Alerts {
        /// Path: `/orgs/{org}/secret-scanning/alerts`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/orgs/{org}/settings`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Settings {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/orgs/{org}/settings/billing`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Settings.Billing {
    public var actions: Actions {
        Actions(path: path + "/actions")
    }

    public struct Actions {
        /// Path: `/orgs/{org}/settings/billing/actions`
        public let path: String

        /// Get GitHub Actions billing for an organization
        public func get() -> Request<ActionsBillingUsage> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Settings.Billing {
    public var advancedSecurity: AdvancedSecurity {
        AdvancedSecurity(path: path + "/advanced-security")
    }

    public struct AdvancedSecurity {
        /// Path: `/orgs/{org}/settings/billing/advanced-security`
        public let path: String

        /// Get GitHub Advanced Security active committers for an organization
        public func get() -> Request<AdvancedSecurityActiveCommitters> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Settings.Billing {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/orgs/{org}/settings/billing/packages`
        public let path: String

        /// Get GitHub Packages billing for an organization
        public func get() -> Request<PackagesBillingUsage> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Settings.Billing {
    public var sharedStorage: SharedStorage {
        SharedStorage(path: path + "/shared-storage")
    }

    public struct SharedStorage {
        /// Path: `/orgs/{org}/settings/billing/shared-storage`
        public let path: String

        /// Get shared storage billing for an organization
        public func get() -> Request<CombinedBillingUsage> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var teamSync: TeamSync {
        TeamSync(path: path + "/team-sync")
    }

    public struct TeamSync {
        /// Path: `/orgs/{org}/team-sync`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.TeamSync {
    public var groups: Groups {
        Groups(path: path + "/groups")
    }

    public struct Groups {
        /// Path: `/orgs/{org}/team-sync/groups`
        public let path: String

        /// List IdP groups for an organization
        public func get() -> Request<GroupMapping> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }
    }
}

extension Paths.Orgs.WithOrg {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/orgs/{org}/teams`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams {
    public func teamSlug(_ teamSlug: String) -> WithTeamSlug {
        WithTeamSlug(path: path + "/" + teamSlug)
    }

    public struct WithTeamSlug {
        /// Path: `/orgs/{org}/teams/{team_slug}`
        public let path: String

        /// Get a team by name
        public func get() -> Request<TeamFull> {
            .get(path)
        }

        /// Delete a team
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var discussions: Discussions {
        Discussions(path: path + "/discussions")
    }

    public struct Discussions {
        /// Path: `/orgs/{org}/teams/{team_slug}/discussions`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Discussions {
    public func discussionNumber(_ discussionNumber: String) -> WithDiscussionNumber {
        WithDiscussionNumber(path: path + "/" + discussionNumber)
    }

    public struct WithDiscussionNumber {
        /// Path: `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}`
        public let path: String

        /// Get a discussion
        public func get() -> Request<TeamDiscussion> {
            .get(path)
        }

        /// Delete a discussion
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Discussions.WithDiscussionNumber {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Discussions.WithDiscussionNumber.Comments {
    public func commentNumber(_ commentNumber: String) -> WithCommentNumber {
        WithCommentNumber(path: path + "/" + commentNumber)
    }

    public struct WithCommentNumber {
        /// Path: `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}`
        public let path: String

        /// Get a discussion comment
        public func get() -> Request<TeamDiscussionComment> {
            .get(path)
        }

        /// Delete a discussion comment
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Discussions.WithDiscussionNumber.Comments.WithCommentNumber {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Discussions.WithDiscussionNumber.Comments.WithCommentNumber.Reactions {
    public func reactionID(_ reactionID: String) -> WithReactionID {
        WithReactionID(path: path + "/" + reactionID)
    }

    public struct WithReactionID {
        /// Path: `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}`
        public let path: String

        /// Delete team discussion comment reaction
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Discussions.WithDiscussionNumber {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Discussions.WithDiscussionNumber.Reactions {
    public func reactionID(_ reactionID: String) -> WithReactionID {
        WithReactionID(path: path + "/" + reactionID)
    }

    public struct WithReactionID {
        /// Path: `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}`
        public let path: String

        /// Delete team discussion reaction
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var externalGroups: ExternalGroups {
        ExternalGroups(path: path + "/external-groups")
    }

    public struct ExternalGroups {
        /// Path: `/orgs/{org}/teams/{team_slug}/external-groups`
        public let path: String

        /// Remove the connection between an external group and a team
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var invitations: Invitations {
        Invitations(path: path + "/invitations")
    }

    public struct Invitations {
        /// Path: `/orgs/{org}/teams/{team_slug}/invitations`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/orgs/{org}/teams/{team_slug}/members`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var memberships: Memberships {
        Memberships(path: path + "/memberships")
    }

    public struct Memberships {
        /// Path: `/orgs/{org}/teams/{team_slug}/memberships`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Memberships {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/orgs/{org}/teams/{team_slug}/memberships/{username}`
        public let path: String

        /// Get team membership for a user
        public func get() -> Request<TeamMembership> {
            .get(path)
        }

        /// Remove team membership for a user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var projects: Projects {
        Projects(path: path + "/projects")
    }

    public struct Projects {
        /// Path: `/orgs/{org}/teams/{team_slug}/projects`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Projects {
    public func projectID(_ projectID: String) -> WithProjectID {
        WithProjectID(path: path + "/" + projectID)
    }

    public struct WithProjectID {
        /// Path: `/orgs/{org}/teams/{team_slug}/projects/{project_id}`
        public let path: String

        /// Check team permissions for a project
        public func get() -> Request<TeamProject> {
            .get(path)
        }

        /// Remove a project from a team
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/orgs/{org}/teams/{team_slug}/repos`
        public let path: String


    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Repos {
    public func owner(_ owner: String) -> WithOwner {
        WithOwner(path: path + "/" + owner)
    }

    public struct WithOwner {
        /// Path: `/orgs/{org}/teams/{team_slug}/repos/{owner}`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.Repos.WithOwner {
    public func repo(_ repo: String) -> WithRepo {
        WithRepo(path: path + "/" + repo)
    }

    public struct WithRepo {
        /// Path: `/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}`
        public let path: String

        /// Check team permissions for a repository
        public func get() -> Request<TeamRepository> {
            .get(path)
        }

        /// Remove a repository from a team
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var teamSync: TeamSync {
        TeamSync(path: path + "/team-sync")
    }

    public struct TeamSync {
        /// Path: `/orgs/{org}/teams/{team_slug}/team-sync`
        public let path: String
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug.TeamSync {
    public var groupMappings: GroupMappings {
        GroupMappings(path: path + "/group-mappings")
    }

    public struct GroupMappings {
        /// Path: `/orgs/{org}/teams/{team_slug}/team-sync/group-mappings`
        public let path: String

        /// List IdP groups for a team
        public func get() -> Request<GroupMapping> {
            .get(path)
        }
    }
}

extension Paths.Orgs.WithOrg.Teams.WithTeamSlug {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/orgs/{org}/teams/{team_slug}/teams`
        public let path: String


    }
}

extension Paths {
    public static var projects: Projects {
        Projects(path: "/projects")
    }

    public struct Projects {
        /// Path: `/projects`
        public let path: String
    }
}

extension Paths.Projects {
    public var columns: Columns {
        Columns(path: path + "/columns")
    }

    public struct Columns {
        /// Path: `/projects/columns`
        public let path: String
    }
}

extension Paths.Projects.Columns {
    public var cards: Cards {
        Cards(path: path + "/cards")
    }

    public struct Cards {
        /// Path: `/projects/columns/cards`
        public let path: String
    }
}

extension Paths.Projects.Columns.Cards {
    public func cardID(_ cardID: String) -> WithCardID {
        WithCardID(path: path + "/" + cardID)
    }

    public struct WithCardID {
        /// Path: `/projects/columns/cards/{card_id}`
        public let path: String

        /// Get a project card
        public func get() -> Request<ProjectCard> {
            .get(path)
        }

        /// Delete a project card
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Projects.Columns.Cards.WithCardID {
    public var moves: Moves {
        Moves(path: path + "/moves")
    }

    public struct Moves {
        /// Path: `/projects/columns/cards/{card_id}/moves`
        public let path: String


    }
}

extension Paths.Projects.Columns {
    public func columnID(_ columnID: String) -> WithColumnID {
        WithColumnID(path: path + "/" + columnID)
    }

    public struct WithColumnID {
        /// Path: `/projects/columns/{column_id}`
        public let path: String

        /// Get a project column
        public func get() -> Request<ProjectColumn> {
            .get(path)
        }

        /// Delete a project column
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Projects.Columns.WithColumnID {
    public var cards: Cards {
        Cards(path: path + "/cards")
    }

    public struct Cards {
        /// Path: `/projects/columns/{column_id}/cards`
        public let path: String


    }
}

extension Paths.Projects.Columns.WithColumnID {
    public var moves: Moves {
        Moves(path: path + "/moves")
    }

    public struct Moves {
        /// Path: `/projects/columns/{column_id}/moves`
        public let path: String


    }
}

extension Paths.Projects {
    public func projectID(_ projectID: String) -> WithProjectID {
        WithProjectID(path: path + "/" + projectID)
    }

    public struct WithProjectID {
        /// Path: `/projects/{project_id}`
        public let path: String

        /// Get a project
        public func get() -> Request<Project> {
            .get(path)
        }

        /// Delete a project
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Projects.WithProjectID {
    public var collaborators: Collaborators {
        Collaborators(path: path + "/collaborators")
    }

    public struct Collaborators {
        /// Path: `/projects/{project_id}/collaborators`
        public let path: String


    }
}

extension Paths.Projects.WithProjectID.Collaborators {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/projects/{project_id}/collaborators/{username}`
        public let path: String

        /// Remove user as a collaborator
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Projects.WithProjectID.Collaborators.WithUsername {
    public var permission: Permission {
        Permission(path: path + "/permission")
    }

    public struct Permission {
        /// Path: `/projects/{project_id}/collaborators/{username}/permission`
        public let path: String

        /// Get project permission for a user
        public func get() -> Request<ProjectCollaboratorPermission> {
            .get(path)
        }
    }
}

extension Paths.Projects.WithProjectID {
    public var columns: Columns {
        Columns(path: path + "/columns")
    }

    public struct Columns {
        /// Path: `/projects/{project_id}/columns`
        public let path: String


    }
}

extension Paths {
    public static var rateLimit: RateLimit {
        RateLimit(path: "/rate_limit")
    }

    public struct RateLimit {
        /// Path: `/rate_limit`
        public let path: String

        /// Get rate limit status for the authenticated user
        public func get() -> Request<RateLimitOverview> {
            .get(path)
        }

        public enum GetHeaders {
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
        }
    }
}

extension Paths {
    public static var reactions: Reactions {
        Reactions(path: "/reactions")
    }

    public struct Reactions {
        /// Path: `/reactions`
        public let path: String
    }
}

extension Paths.Reactions {
    public func reactionID(_ reactionID: String) -> WithReactionID {
        WithReactionID(path: path + "/" + reactionID)
    }

    public struct WithReactionID {
        /// Path: `/reactions/{reaction_id}`
        public let path: String

        /// Delete a reaction (Legacy)
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var repos: Repos {
        Repos(path: "/repos")
    }

    public struct Repos {
        /// Path: `/repos`
        public let path: String
    }
}

extension Paths.Repos {
    public func owner(_ owner: String) -> WithOwner {
        WithOwner(path: path + "/" + owner)
    }

    public struct WithOwner {
        /// Path: `/repos/{owner}`
        public let path: String
    }
}

extension Paths.Repos.WithOwner {
    public func repo(_ repo: String) -> WithRepo {
        WithRepo(path: path + "/" + repo)
    }

    public struct WithRepo {
        /// Path: `/repos/{owner}/{repo}`
        public let path: String

        /// Get a repository
        public func get() -> Request<FullRepository> {
            .get(path)
        }

        /// Delete a repository
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var actions: Actions {
        Actions(path: path + "/actions")
    }

    public struct Actions {
        /// Path: `/repos/{owner}/{repo}/actions`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions {
    public var artifacts: Artifacts {
        Artifacts(path: path + "/artifacts")
    }

    public struct Artifacts {
        /// Path: `/repos/{owner}/{repo}/actions/artifacts`
        public let path: String

        /// List artifacts for a repository
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var artifacts: [OctoKit.Artifact]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.artifacts = try values.decode([OctoKit.Artifact].self, forKey: "artifacts")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(artifacts, forKey: "artifacts")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Artifacts {
    public func artifactID(_ artifactID: String) -> WithArtifactID {
        WithArtifactID(path: path + "/" + artifactID)
    }

    public struct WithArtifactID {
        /// Path: `/repos/{owner}/{repo}/actions/artifacts/{artifact_id}`
        public let path: String

        /// Get an artifact
        public func get() -> Request<Artifact> {
            .get(path)
        }

        /// Delete an artifact
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Artifacts.WithArtifactID {
    public func archiveFormat(_ archiveFormat: String) -> WithArchiveFormat {
        WithArchiveFormat(path: path + "/" + archiveFormat)
    }

    public struct WithArchiveFormat {
        /// Path: `/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}`
        public let path: String

        /// Download an artifact
        public func get() -> Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions {
    public var jobs: Jobs {
        Jobs(path: path + "/jobs")
    }

    public struct Jobs {
        /// Path: `/repos/{owner}/{repo}/actions/jobs`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Jobs {
    public func jobID(_ jobID: String) -> WithJobID {
        WithJobID(path: path + "/" + jobID)
    }

    public struct WithJobID {
        /// Path: `/repos/{owner}/{repo}/actions/jobs/{job_id}`
        public let path: String

        /// Get a job for a workflow run
        public func get() -> Request<Job> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Jobs.WithJobID {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/repos/{owner}/{repo}/actions/jobs/{job_id}/logs`
        public let path: String

        /// Download job logs for a workflow run
        public func get() -> Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions {
    public var permissions: Permissions {
        Permissions(path: path + "/permissions")
    }

    public struct Permissions {
        /// Path: `/repos/{owner}/{repo}/actions/permissions`
        public let path: String

        /// Get GitHub Actions permissions for a repository
        public func get() -> Request<ActionsRepositoryPermissions> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Permissions {
    public var selectedActions: SelectedActions {
        SelectedActions(path: path + "/selected-actions")
    }

    public struct SelectedActions {
        /// Path: `/repos/{owner}/{repo}/actions/permissions/selected-actions`
        public let path: String

        /// Get allowed actions for a repository
        public func get() -> Request<OctoKit.SelectedActions> {
            .get(path)
        }

        /// Set allowed actions for a repository
        public func put(_ body: OctoKit.SelectedActions) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions {
    public var runners: Runners {
        Runners(path: path + "/runners")
    }

    public struct Runners {
        /// Path: `/repos/{owner}/{repo}/actions/runners`
        public let path: String

        /// List self-hosted runners for a repository
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var runners: [OctoKit.Runner]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.runners = try values.decode([OctoKit.Runner].self, forKey: "runners")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(runners, forKey: "runners")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runners {
    public var downloads: Downloads {
        Downloads(path: path + "/downloads")
    }

    public struct Downloads {
        /// Path: `/repos/{owner}/{repo}/actions/runners/downloads`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runners {
    public var registrationToken: RegistrationToken {
        RegistrationToken(path: path + "/registration-token")
    }

    public struct RegistrationToken {
        /// Path: `/repos/{owner}/{repo}/actions/runners/registration-token`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runners {
    public var removeToken: RemoveToken {
        RemoveToken(path: path + "/remove-token")
    }

    public struct RemoveToken {
        /// Path: `/repos/{owner}/{repo}/actions/runners/remove-token`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runners {
    public func runnerID(_ runnerID: String) -> WithRunnerID {
        WithRunnerID(path: path + "/" + runnerID)
    }

    public struct WithRunnerID {
        /// Path: `/repos/{owner}/{repo}/actions/runners/{runner_id}`
        public let path: String

        /// Get a self-hosted runner for a repository
        public func get() -> Request<Runner> {
            .get(path)
        }

        /// Delete a self-hosted runner from a repository
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions {
    public var runs: Runs {
        Runs(path: path + "/runs")
    }

    public struct Runs {
        /// Path: `/repos/{owner}/{repo}/actions/runs`
        public let path: String

        /// List workflow runs for a repository
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var totalCount: Int
            public var workflowRuns: [OctoKit.WorkflowRun]

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
                self.workflowRuns = try values.decode([OctoKit.WorkflowRun].self, forKey: "workflow_runs")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(totalCount, forKey: "total_count")
                try values.encode(workflowRuns, forKey: "workflow_runs")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs {
    public func runID(_ runID: String) -> WithRunID {
        WithRunID(path: path + "/" + runID)
    }

    public struct WithRunID {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}`
        public let path: String

        /// Get a workflow run
        public func get() -> Request<WorkflowRun> {
            .get(path)
        }

        /// Delete a workflow run
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var approvals: Approvals {
        Approvals(path: path + "/approvals")
    }

    public struct Approvals {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/approvals`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var approve: Approve {
        Approve(path: path + "/approve")
    }

    public struct Approve {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/approve`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var artifacts: Artifacts {
        Artifacts(path: path + "/artifacts")
    }

    public struct Artifacts {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts`
        public let path: String

        /// List workflow run artifacts
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var artifacts: [OctoKit.Artifact]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.artifacts = try values.decode([OctoKit.Artifact].self, forKey: "artifacts")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(artifacts, forKey: "artifacts")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var attempts: Attempts {
        Attempts(path: path + "/attempts")
    }

    public struct Attempts {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/attempts`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID.Attempts {
    public func attemptNumber(_ attemptNumber: String) -> WithAttemptNumber {
        WithAttemptNumber(path: path + "/" + attemptNumber)
    }

    public struct WithAttemptNumber {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}`
        public let path: String

        /// Get a workflow run attempt
        public func get() -> Request<WorkflowRun> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID.Attempts.WithAttemptNumber {
    public var jobs: Jobs {
        Jobs(path: path + "/jobs")
    }

    public struct Jobs {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs`
        public let path: String

        /// List jobs for a workflow run attempt
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var jobs: [OctoKit.Job]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.jobs = try values.decode([OctoKit.Job].self, forKey: "jobs")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(jobs, forKey: "jobs")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID.Attempts.WithAttemptNumber {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs`
        public let path: String

        /// Download workflow run attempt logs
        public func get() -> Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/cancel`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var jobs: Jobs {
        Jobs(path: path + "/jobs")
    }

    public struct Jobs {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/jobs`
        public let path: String

        /// List jobs for a workflow run
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var jobs: [OctoKit.Job]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.jobs = try values.decode([OctoKit.Job].self, forKey: "jobs")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(jobs, forKey: "jobs")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/logs`
        public let path: String

        /// Download workflow run logs
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Delete workflow run logs
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var pendingDeployments: PendingDeployments {
        PendingDeployments(path: path + "/pending_deployments")
    }

    public struct PendingDeployments {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var rerun: Rerun {
        Rerun(path: path + "/rerun")
    }

    public struct Rerun {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/rerun`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Runs.WithRunID {
    public var timing: Timing {
        Timing(path: path + "/timing")
    }

    public struct Timing {
        /// Path: `/repos/{owner}/{repo}/actions/runs/{run_id}/timing`
        public let path: String

        /// Get workflow run usage
        public func get() -> Request<WorkflowRunUsage> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions {
    public var secrets: Secrets {
        Secrets(path: path + "/secrets")
    }

    public struct Secrets {
        /// Path: `/repos/{owner}/{repo}/actions/secrets`
        public let path: String

        /// List repository secrets
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var secrets: [OctoKit.ActionsSecret]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.secrets = try values.decode([OctoKit.ActionsSecret].self, forKey: "secrets")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(secrets, forKey: "secrets")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Secrets {
    public var publicKey: PublicKey {
        PublicKey(path: path + "/public-key")
    }

    public struct PublicKey {
        /// Path: `/repos/{owner}/{repo}/actions/secrets/public-key`
        public let path: String

        /// Get a repository public key
        public func get() -> Request<ActionsPublicKey> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Secrets {
    public func secretName(_ secretName: String) -> WithSecretName {
        WithSecretName(path: path + "/" + secretName)
    }

    public struct WithSecretName {
        /// Path: `/repos/{owner}/{repo}/actions/secrets/{secret_name}`
        public let path: String

        /// Get a repository secret
        public func get() -> Request<ActionsSecret> {
            .get(path)
        }

        /// Delete a repository secret
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions {
    public var workflows: Workflows {
        Workflows(path: path + "/workflows")
    }

    public struct Workflows {
        /// Path: `/repos/{owner}/{repo}/actions/workflows`
        public let path: String

        /// List repository workflows
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var totalCount: Int
            public var workflows: [OctoKit.Workflow]

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
                self.workflows = try values.decode([OctoKit.Workflow].self, forKey: "workflows")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(totalCount, forKey: "total_count")
                try values.encode(workflows, forKey: "workflows")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Workflows {
    public func workflowID(_ workflowID: String) -> WithWorkflowID {
        WithWorkflowID(path: path + "/" + workflowID)
    }

    public struct WithWorkflowID {
        /// Path: `/repos/{owner}/{repo}/actions/workflows/{workflow_id}`
        public let path: String

        /// Get a workflow
        public func get() -> Request<Workflow> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Workflows.WithWorkflowID {
    public var disable: Disable {
        Disable(path: path + "/disable")
    }

    public struct Disable {
        /// Path: `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Workflows.WithWorkflowID {
    public var dispatches: Dispatches {
        Dispatches(path: path + "/dispatches")
    }

    public struct Dispatches {
        /// Path: `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Workflows.WithWorkflowID {
    public var enable: Enable {
        Enable(path: path + "/enable")
    }

    public struct Enable {
        /// Path: `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Workflows.WithWorkflowID {
    public var runs: Runs {
        Runs(path: path + "/runs")
    }

    public struct Runs {
        /// Path: `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs`
        public let path: String

        /// List workflow runs
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var totalCount: Int
            public var workflowRuns: [OctoKit.WorkflowRun]

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
                self.workflowRuns = try values.decode([OctoKit.WorkflowRun].self, forKey: "workflow_runs")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(totalCount, forKey: "total_count")
                try values.encode(workflowRuns, forKey: "workflow_runs")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Actions.Workflows.WithWorkflowID {
    public var timing: Timing {
        Timing(path: path + "/timing")
    }

    public struct Timing {
        /// Path: `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing`
        public let path: String

        /// Get workflow usage
        public func get() -> Request<WorkflowUsage> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var assignees: Assignees {
        Assignees(path: path + "/assignees")
    }

    public struct Assignees {
        /// Path: `/repos/{owner}/{repo}/assignees`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Assignees {
    public func assignee(_ assignee: String) -> WithAssignee {
        WithAssignee(path: path + "/" + assignee)
    }

    public struct WithAssignee {
        /// Path: `/repos/{owner}/{repo}/assignees/{assignee}`
        public let path: String

        /// Check if a user can be assigned
        public func get() -> Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var autolinks: Autolinks {
        Autolinks(path: path + "/autolinks")
    }

    public struct Autolinks {
        /// Path: `/repos/{owner}/{repo}/autolinks`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Autolinks {
    public func autolinkID(_ autolinkID: String) -> WithAutolinkID {
        WithAutolinkID(path: path + "/" + autolinkID)
    }

    public struct WithAutolinkID {
        /// Path: `/repos/{owner}/{repo}/autolinks/{autolink_id}`
        public let path: String

        /// Get an autolink reference of a repository
        public func get() -> Request<Autolink> {
            .get(path)
        }

        /// Delete an autolink reference from a repository
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var automatedSecurityFixes: AutomatedSecurityFixes {
        AutomatedSecurityFixes(path: path + "/automated-security-fixes")
    }

    public struct AutomatedSecurityFixes {
        /// Path: `/repos/{owner}/{repo}/automated-security-fixes`
        public let path: String

        /// Disable automated security fixes
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var branches: Branches {
        Branches(path: path + "/branches")
    }

    public struct Branches {
        /// Path: `/repos/{owner}/{repo}/branches`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches {
    public func branch(_ branch: String) -> WithBranch {
        WithBranch(path: path + "/" + branch)
    }

    public struct WithBranch {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}`
        public let path: String

        /// Get a branch
        public func get() -> Request<BranchWithProtection> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch {
    public var protection: Protection {
        Protection(path: path + "/protection")
    }

    public struct Protection {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection`
        public let path: String

        /// Get branch protection
        public func get() -> Request<BranchProtection> {
            .get(path)
        }

        /// Delete branch protection
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection {
    public var enforceAdmins: EnforceAdmins {
        EnforceAdmins(path: path + "/enforce_admins")
    }

    public struct EnforceAdmins {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`
        public let path: String

        /// Get admin branch protection
        public func get() -> Request<ProtectedBranchAdminEnforced> {
            .get(path)
        }

        /// Delete admin branch protection
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection {
    public var requiredPullRequestReviews: RequiredPullRequestReviews {
        RequiredPullRequestReviews(path: path + "/required_pull_request_reviews")
    }

    public struct RequiredPullRequestReviews {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`
        public let path: String

        /// Get pull request review protection
        public func get() -> Request<ProtectedBranchPullRequestReview> {
            .get(path)
        }

        /// Delete pull request review protection
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection {
    public var requiredSignatures: RequiredSignatures {
        RequiredSignatures(path: path + "/required_signatures")
    }

    public struct RequiredSignatures {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`
        public let path: String

        /// Get commit signature protection
        public func get() -> Request<ProtectedBranchAdminEnforced> {
            .get(path)
        }

        /// Delete commit signature protection
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection {
    public var requiredStatusChecks: RequiredStatusChecks {
        RequiredStatusChecks(path: path + "/required_status_checks")
    }

    public struct RequiredStatusChecks {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`
        public let path: String

        /// Get status checks protection
        public func get() -> Request<StatusCheckPolicy> {
            .get(path)
        }

        /// Remove status check protection
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection.RequiredStatusChecks {
    public var contexts: Contexts {
        Contexts(path: path + "/contexts")
    }

    public struct Contexts {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection {
    public var restrictions: Restrictions {
        Restrictions(path: path + "/restrictions")
    }

    public struct Restrictions {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions`
        public let path: String

        /// Get access restrictions
        public func get() -> Request<BranchRestrictionPolicy> {
            .get(path)
        }

        /// Delete access restrictions
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection.Restrictions {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection.Restrictions {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch.Protection.Restrictions {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Branches.WithBranch {
    public var rename: Rename {
        Rename(path: path + "/rename")
    }

    public struct Rename {
        /// Path: `/repos/{owner}/{repo}/branches/{branch}/rename`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var checkRuns: CheckRuns {
        CheckRuns(path: path + "/check-runs")
    }

    public struct CheckRuns {
        /// Path: `/repos/{owner}/{repo}/check-runs`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.CheckRuns {
    public func checkRunID(_ checkRunID: String) -> WithCheckRunID {
        WithCheckRunID(path: path + "/" + checkRunID)
    }

    public struct WithCheckRunID {
        /// Path: `/repos/{owner}/{repo}/check-runs/{check_run_id}`
        public let path: String

        /// Get a check run
        public func get() -> Request<CheckRun> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.CheckRuns.WithCheckRunID {
    public var annotations: Annotations {
        Annotations(path: path + "/annotations")
    }

    public struct Annotations {
        /// Path: `/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.CheckRuns.WithCheckRunID {
    public var rerequest: Rerequest {
        Rerequest(path: path + "/rerequest")
    }

    public struct Rerequest {
        /// Path: `/repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var checkSuites: CheckSuites {
        CheckSuites(path: path + "/check-suites")
    }

    public struct CheckSuites {
        /// Path: `/repos/{owner}/{repo}/check-suites`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.CheckSuites {
    public var preferences: Preferences {
        Preferences(path: path + "/preferences")
    }

    public struct Preferences {
        /// Path: `/repos/{owner}/{repo}/check-suites/preferences`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.CheckSuites {
    public func checkSuiteID(_ checkSuiteID: String) -> WithCheckSuiteID {
        WithCheckSuiteID(path: path + "/" + checkSuiteID)
    }

    public struct WithCheckSuiteID {
        /// Path: `/repos/{owner}/{repo}/check-suites/{check_suite_id}`
        public let path: String

        /// Get a check suite
        public func get() -> Request<CheckSuite> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.CheckSuites.WithCheckSuiteID {
    public var checkRuns: CheckRuns {
        CheckRuns(path: path + "/check-runs")
    }

    public struct CheckRuns {
        /// Path: `/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs`
        public let path: String

        /// List check runs in a check suite
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var checkRuns: [OctoKit.CheckRun]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.checkRuns = try values.decode([OctoKit.CheckRun].self, forKey: "check_runs")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(checkRuns, forKey: "check_runs")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.CheckSuites.WithCheckSuiteID {
    public var rerequest: Rerequest {
        Rerequest(path: path + "/rerequest")
    }

    public struct Rerequest {
        /// Path: `/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var codeScanning: CodeScanning {
        CodeScanning(path: path + "/code-scanning")
    }

    public struct CodeScanning {
        /// Path: `/repos/{owner}/{repo}/code-scanning`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.CodeScanning {
    public var alerts: Alerts {
        Alerts(path: path + "/alerts")
    }

    public struct Alerts {
        /// Path: `/repos/{owner}/{repo}/code-scanning/alerts`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.CodeScanning.Alerts {
    public func alertNumber(_ alertNumber: String) -> WithAlertNumber {
        WithAlertNumber(path: path + "/" + alertNumber)
    }

    public struct WithAlertNumber {
        /// Path: `/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}`
        public let path: String

        /// Get a code scanning alert
        public func get() -> Request<CodeScanningAlert> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.CodeScanning.Alerts.WithAlertNumber {
    public var instances: Instances {
        Instances(path: path + "/instances")
    }

    public struct Instances {
        /// Path: `/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.CodeScanning {
    public var analyses: Analyses {
        Analyses(path: path + "/analyses")
    }

    public struct Analyses {
        /// Path: `/repos/{owner}/{repo}/code-scanning/analyses`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.CodeScanning.Analyses {
    public func analysisID(_ analysisID: String) -> WithAnalysisID {
        WithAnalysisID(path: path + "/" + analysisID)
    }

    public struct WithAnalysisID {
        /// Path: `/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}`
        public let path: String

        /// Get a code scanning analysis for a repository
        public func get() -> Request<CodeScanningAnalysis> {
            .get(path)
        }

        /// Delete a code scanning analysis from a repository
        public func delete() -> Request<CodeScanningAnalysisDeletion> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.CodeScanning {
    public var sarifs: Sarifs {
        Sarifs(path: path + "/sarifs")
    }

    public struct Sarifs {
        /// Path: `/repos/{owner}/{repo}/code-scanning/sarifs`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.CodeScanning.Sarifs {
    public func sarifID(_ sarifID: String) -> WithSarifID {
        WithSarifID(path: path + "/" + sarifID)
    }

    public struct WithSarifID {
        /// Path: `/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}`
        public let path: String

        /// Get information about a SARIF upload
        public func get() -> Request<CodeScanningSarifsStatus> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var codespaces: Codespaces {
        Codespaces(path: path + "/codespaces")
    }

    public struct Codespaces {
        /// Path: `/repos/{owner}/{repo}/codespaces`
        public let path: String

        /// List codespaces in a repository for the authenticated user
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var codespaces: [OctoKit.Codespace]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.codespaces = try values.decode([OctoKit.Codespace].self, forKey: "codespaces")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(codespaces, forKey: "codespaces")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Codespaces {
    public var machines: Machines {
        Machines(path: path + "/machines")
    }

    public struct Machines {
        /// Path: `/repos/{owner}/{repo}/codespaces/machines`
        public let path: String

        /// List available machine types for a repository
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var machines: [OctoKit.CodespaceMachine]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.machines = try values.decode([OctoKit.CodespaceMachine].self, forKey: "machines")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(machines, forKey: "machines")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var collaborators: Collaborators {
        Collaborators(path: path + "/collaborators")
    }

    public struct Collaborators {
        /// Path: `/repos/{owner}/{repo}/collaborators`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Collaborators {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/repos/{owner}/{repo}/collaborators/{username}`
        public let path: String

        /// Check if a user is a repository collaborator
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Remove a repository collaborator
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Collaborators.WithUsername {
    public var permission: Permission {
        Permission(path: path + "/permission")
    }

    public struct Permission {
        /// Path: `/repos/{owner}/{repo}/collaborators/{username}/permission`
        public let path: String

        /// Get repository permissions for a user
        public func get() -> Request<RepositoryCollaboratorPermission> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/repos/{owner}/{repo}/comments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Comments {
    public func commentID(_ commentID: String) -> WithCommentID {
        WithCommentID(path: path + "/" + commentID)
    }

    public struct WithCommentID {
        /// Path: `/repos/{owner}/{repo}/comments/{comment_id}`
        public let path: String

        /// Get a commit comment
        public func get() -> Request<CommitComment> {
            .get(path)
        }

        /// Delete a commit comment
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Comments.WithCommentID {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/repos/{owner}/{repo}/comments/{comment_id}/reactions`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Comments.WithCommentID.Reactions {
    public func reactionID(_ reactionID: String) -> WithReactionID {
        WithReactionID(path: path + "/" + reactionID)
    }

    public struct WithReactionID {
        /// Path: `/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}`
        public let path: String

        /// Delete a commit comment reaction
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var commits: Commits {
        Commits(path: path + "/commits")
    }

    public struct Commits {
        /// Path: `/repos/{owner}/{repo}/commits`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits {
    public func commitSha(_ commitSha: String) -> WithCommitSha {
        WithCommitSha(path: path + "/" + commitSha)
    }

    public struct WithCommitSha {
        /// Path: `/repos/{owner}/{repo}/commits/{commit_sha}`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits.WithCommitSha {
    public var branchesWhereHead: BranchesWhereHead {
        BranchesWhereHead(path: path + "/branches-where-head")
    }

    public struct BranchesWhereHead {
        /// Path: `/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits.WithCommitSha {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/repos/{owner}/{repo}/commits/{commit_sha}/comments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits.WithCommitSha {
    public var pulls: Pulls {
        Pulls(path: path + "/pulls")
    }

    public struct Pulls {
        /// Path: `/repos/{owner}/{repo}/commits/{commit_sha}/pulls`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits {
    public func ref(_ ref: String) -> WithRef {
        WithRef(path: path + "/" + ref)
    }

    public struct WithRef {
        /// Path: `/repos/{owner}/{repo}/commits/{ref}`
        public let path: String

        /// Get a commit
        public func get() -> Request<Commit> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits.WithRef {
    public var checkRuns: CheckRuns {
        CheckRuns(path: path + "/check-runs")
    }

    public struct CheckRuns {
        /// Path: `/repos/{owner}/{repo}/commits/{ref}/check-runs`
        public let path: String

        /// List check runs for a Git reference
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var checkRuns: [OctoKit.CheckRun]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.checkRuns = try values.decode([OctoKit.CheckRun].self, forKey: "check_runs")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(checkRuns, forKey: "check_runs")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits.WithRef {
    public var checkSuites: CheckSuites {
        CheckSuites(path: path + "/check-suites")
    }

    public struct CheckSuites {
        /// Path: `/repos/{owner}/{repo}/commits/{ref}/check-suites`
        public let path: String

        /// List check suites for a Git reference
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var checkSuites: [OctoKit.CheckSuite]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.checkSuites = try values.decode([OctoKit.CheckSuite].self, forKey: "check_suites")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(checkSuites, forKey: "check_suites")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits.WithRef {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/repos/{owner}/{repo}/commits/{ref}/status`
        public let path: String

        /// Get the combined status for a specific reference
        public func get() -> Request<CombinedCommitStatus> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Commits.WithRef {
    public var statuses: Statuses {
        Statuses(path: path + "/statuses")
    }

    public struct Statuses {
        /// Path: `/repos/{owner}/{repo}/commits/{ref}/statuses`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var community: Community {
        Community(path: path + "/community")
    }

    public struct Community {
        /// Path: `/repos/{owner}/{repo}/community`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Community {
    public var profile: Profile {
        Profile(path: path + "/profile")
    }

    public struct Profile {
        /// Path: `/repos/{owner}/{repo}/community/profile`
        public let path: String

        /// Get community profile metrics
        public func get() -> Request<CommunityProfile> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var compare: Compare {
        Compare(path: path + "/compare")
    }

    public struct Compare {
        /// Path: `/repos/{owner}/{repo}/compare`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Compare {
    public func basehead(_ basehead: String) -> WithBasehead {
        WithBasehead(path: path + "/" + basehead)
    }

    public struct WithBasehead {
        /// Path: `/repos/{owner}/{repo}/compare/{basehead}`
        public let path: String

        /// Compare two commits
        public func get() -> Request<CommitComparison> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var contentReferences: ContentReferences {
        ContentReferences(path: path + "/content_references")
    }

    public struct ContentReferences {
        /// Path: `/repos/{owner}/{repo}/content_references`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.ContentReferences {
    public func contentReferenceID(_ contentReferenceID: String) -> WithContentReferenceID {
        WithContentReferenceID(path: path + "/" + contentReferenceID)
    }

    public struct WithContentReferenceID {
        /// Path: `/repos/{owner}/{repo}/content_references/{content_reference_id}`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.ContentReferences.WithContentReferenceID {
    public var attachments: Attachments {
        Attachments(path: path + "/attachments")
    }

    public struct Attachments {
        /// Path: `/repos/{owner}/{repo}/content_references/{content_reference_id}/attachments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var contents: Contents {
        Contents(path: path + "/contents")
    }

    public struct Contents {
        /// Path: `/repos/{owner}/{repo}/contents`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Contents {
    public func path(_ path: String) -> WithPath {
        WithPath(path: path + "/" + path)
    }

    public struct WithPath {
        /// Path: `/repos/{owner}/{repo}/contents/{path}`
        public let path: String

        /// Delete a file
        public func delete() -> Request<FileCommit> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var contributors: Contributors {
        Contributors(path: path + "/contributors")
    }

    public struct Contributors {
        /// Path: `/repos/{owner}/{repo}/contributors`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var deployments: Deployments {
        Deployments(path: path + "/deployments")
    }

    public struct Deployments {
        /// Path: `/repos/{owner}/{repo}/deployments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Deployments {
    public func deploymentID(_ deploymentID: String) -> WithDeploymentID {
        WithDeploymentID(path: path + "/" + deploymentID)
    }

    public struct WithDeploymentID {
        /// Path: `/repos/{owner}/{repo}/deployments/{deployment_id}`
        public let path: String

        /// Get a deployment
        public func get() -> Request<Deployment> {
            .get(path)
        }

        /// Delete a deployment
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Deployments.WithDeploymentID {
    public var statuses: Statuses {
        Statuses(path: path + "/statuses")
    }

    public struct Statuses {
        /// Path: `/repos/{owner}/{repo}/deployments/{deployment_id}/statuses`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Deployments.WithDeploymentID.Statuses {
    public func statusID(_ statusID: String) -> WithStatusID {
        WithStatusID(path: path + "/" + statusID)
    }

    public struct WithStatusID {
        /// Path: `/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}`
        public let path: String

        /// Get a deployment status
        public func get() -> Request<DeploymentStatus> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var dispatches: Dispatches {
        Dispatches(path: path + "/dispatches")
    }

    public struct Dispatches {
        /// Path: `/repos/{owner}/{repo}/dispatches`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var environments: Environments {
        Environments(path: path + "/environments")
    }

    public struct Environments {
        /// Path: `/repos/{owner}/{repo}/environments`
        public let path: String

        /// Get all environments
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var environments: [OctoKit.Environment]?
            /// The number of environments in this repository
            public var totalCount: Int?

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.environments = try values.decodeIfPresent([OctoKit.Environment].self, forKey: "environments")
                self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(environments, forKey: "environments")
                try values.encodeIfPresent(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Environments {
    public func environmentName(_ environmentName: String) -> WithEnvironmentName {
        WithEnvironmentName(path: path + "/" + environmentName)
    }

    public struct WithEnvironmentName {
        /// Path: `/repos/{owner}/{repo}/environments/{environment_name}`
        public let path: String

        /// Get an environment
        public func get() -> Request<Environment> {
            .get(path)
        }

        /// Delete an environment
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/repos/{owner}/{repo}/events`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var forks: Forks {
        Forks(path: path + "/forks")
    }

    public struct Forks {
        /// Path: `/repos/{owner}/{repo}/forks`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var git: Git {
        Git(path: path + "/git")
    }

    public struct Git {
        /// Path: `/repos/{owner}/{repo}/git`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Git {
    public var blobs: Blobs {
        Blobs(path: path + "/blobs")
    }

    public struct Blobs {
        /// Path: `/repos/{owner}/{repo}/git/blobs`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Git.Blobs {
    public func fileSha(_ fileSha: String) -> WithFileSha {
        WithFileSha(path: path + "/" + fileSha)
    }

    public struct WithFileSha {
        /// Path: `/repos/{owner}/{repo}/git/blobs/{file_sha}`
        public let path: String

        /// Get a blob
        public func get() -> Request<Blob> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Git {
    public var commits: Commits {
        Commits(path: path + "/commits")
    }

    public struct Commits {
        /// Path: `/repos/{owner}/{repo}/git/commits`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Git.Commits {
    public func commitSha(_ commitSha: String) -> WithCommitSha {
        WithCommitSha(path: path + "/" + commitSha)
    }

    public struct WithCommitSha {
        /// Path: `/repos/{owner}/{repo}/git/commits/{commit_sha}`
        public let path: String

        /// Get a commit
        public func get() -> Request<GitCommit> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Git {
    public var matchingRefs: MatchingRefs {
        MatchingRefs(path: path + "/matching-refs")
    }

    public struct MatchingRefs {
        /// Path: `/repos/{owner}/{repo}/git/matching-refs`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Git.MatchingRefs {
    public func ref(_ ref: String) -> WithRef {
        WithRef(path: path + "/" + ref)
    }

    public struct WithRef {
        /// Path: `/repos/{owner}/{repo}/git/matching-refs/{ref}`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Git {
    public var ref: Ref {
        Ref(path: path + "/ref")
    }

    public struct Ref {
        /// Path: `/repos/{owner}/{repo}/git/ref`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Git.Ref {
    public func ref(_ ref: String) -> WithRef {
        WithRef(path: path + "/" + ref)
    }

    public struct WithRef {
        /// Path: `/repos/{owner}/{repo}/git/ref/{ref}`
        public let path: String

        /// Get a reference
        public func get() -> Request<GitRef> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Git {
    public var refs: Refs {
        Refs(path: path + "/refs")
    }

    public struct Refs {
        /// Path: `/repos/{owner}/{repo}/git/refs`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Git.Refs {
    public func ref(_ ref: String) -> WithRef {
        WithRef(path: path + "/" + ref)
    }

    public struct WithRef {
        /// Path: `/repos/{owner}/{repo}/git/refs/{ref}`
        public let path: String

        /// Delete a reference
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Git {
    public var tags: Tags {
        Tags(path: path + "/tags")
    }

    public struct Tags {
        /// Path: `/repos/{owner}/{repo}/git/tags`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Git.Tags {
    public func tagSha(_ tagSha: String) -> WithTagSha {
        WithTagSha(path: path + "/" + tagSha)
    }

    public struct WithTagSha {
        /// Path: `/repos/{owner}/{repo}/git/tags/{tag_sha}`
        public let path: String

        /// Get a tag
        public func get() -> Request<GitTag> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Git {
    public var trees: Trees {
        Trees(path: path + "/trees")
    }

    public struct Trees {
        /// Path: `/repos/{owner}/{repo}/git/trees`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Git.Trees {
    public func treeSha(_ treeSha: String) -> WithTreeSha {
        WithTreeSha(path: path + "/" + treeSha)
    }

    public struct WithTreeSha {
        /// Path: `/repos/{owner}/{repo}/git/trees/{tree_sha}`
        public let path: String

        /// Get a tree
        public func get() -> Request<GitTree> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var hooks: Hooks {
        Hooks(path: path + "/hooks")
    }

    public struct Hooks {
        /// Path: `/repos/{owner}/{repo}/hooks`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Hooks {
    public func hookID(_ hookID: String) -> WithHookID {
        WithHookID(path: path + "/" + hookID)
    }

    public struct WithHookID {
        /// Path: `/repos/{owner}/{repo}/hooks/{hook_id}`
        public let path: String

        /// Get a repository webhook
        public func get() -> Request<Hook> {
            .get(path)
        }

        /// Delete a repository webhook
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Hooks.WithHookID {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/repos/{owner}/{repo}/hooks/{hook_id}/config`
        public let path: String

        /// Get a webhook configuration for a repository
        public func get() -> Request<WebhookConfig> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Hooks.WithHookID {
    public var deliveries: Deliveries {
        Deliveries(path: path + "/deliveries")
    }

    public struct Deliveries {
        /// Path: `/repos/{owner}/{repo}/hooks/{hook_id}/deliveries`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Hooks.WithHookID.Deliveries {
    public func deliveryID(_ deliveryID: String) -> WithDeliveryID {
        WithDeliveryID(path: path + "/" + deliveryID)
    }

    public struct WithDeliveryID {
        /// Path: `/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}`
        public let path: String

        /// Get a delivery for a repository webhook
        public func get() -> Request<HookDelivery> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Hooks.WithHookID.Deliveries.WithDeliveryID {
    public var attempts: Attempts {
        Attempts(path: path + "/attempts")
    }

    public struct Attempts {
        /// Path: `/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Hooks.WithHookID {
    public var pings: Pings {
        Pings(path: path + "/pings")
    }

    public struct Pings {
        /// Path: `/repos/{owner}/{repo}/hooks/{hook_id}/pings`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Hooks.WithHookID {
    public var tests: Tests {
        Tests(path: path + "/tests")
    }

    public struct Tests {
        /// Path: `/repos/{owner}/{repo}/hooks/{hook_id}/tests`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var `import`: Import {
        Import(path: path + "/import")
    }

    public struct Import {
        /// Path: `/repos/{owner}/{repo}/import`
        public let path: String

        /// Get an import status
        public func get() -> Request<OctoKit.Import> {
            .get(path)
        }

        /// Cancel an import
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Import {
    public var authors: Authors {
        Authors(path: path + "/authors")
    }

    public struct Authors {
        /// Path: `/repos/{owner}/{repo}/import/authors`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Import.Authors {
    public func authorID(_ authorID: String) -> WithAuthorID {
        WithAuthorID(path: path + "/" + authorID)
    }

    public struct WithAuthorID {
        /// Path: `/repos/{owner}/{repo}/import/authors/{author_id}`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Import {
    public var largeFiles: LargeFiles {
        LargeFiles(path: path + "/large_files")
    }

    public struct LargeFiles {
        /// Path: `/repos/{owner}/{repo}/import/large_files`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Import {
    public var lfs: Lfs {
        Lfs(path: path + "/lfs")
    }

    public struct Lfs {
        /// Path: `/repos/{owner}/{repo}/import/lfs`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var installation: Installation {
        Installation(path: path + "/installation")
    }

    public struct Installation {
        /// Path: `/repos/{owner}/{repo}/installation`
        public let path: String

        /// Get a repository installation for the authenticated app
        public func get() -> Request<OctoKit.Installation> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var interactionLimits: InteractionLimits {
        InteractionLimits(path: path + "/interaction-limits")
    }

    public struct InteractionLimits {
        /// Path: `/repos/{owner}/{repo}/interaction-limits`
        public let path: String

        /// Set interaction restrictions for a repository
        public func put(_ body: InteractionLimit) -> Request<InteractionLimitResponse> {
            .put(path, body: body)
        }

        /// Remove interaction restrictions for a repository
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var invitations: Invitations {
        Invitations(path: path + "/invitations")
    }

    public struct Invitations {
        /// Path: `/repos/{owner}/{repo}/invitations`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Invitations {
    public func invitationID(_ invitationID: String) -> WithInvitationID {
        WithInvitationID(path: path + "/" + invitationID)
    }

    public struct WithInvitationID {
        /// Path: `/repos/{owner}/{repo}/invitations/{invitation_id}`
        public let path: String

        /// Delete a repository invitation
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var issues: Issues {
        Issues(path: path + "/issues")
    }

    public struct Issues {
        /// Path: `/repos/{owner}/{repo}/issues`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/repos/{owner}/{repo}/issues/comments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.Comments {
    public func commentID(_ commentID: String) -> WithCommentID {
        WithCommentID(path: path + "/" + commentID)
    }

    public struct WithCommentID {
        /// Path: `/repos/{owner}/{repo}/issues/comments/{comment_id}`
        public let path: String

        /// Get an issue comment
        public func get() -> Request<IssueComment> {
            .get(path)
        }

        /// Delete an issue comment
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.Comments.WithCommentID {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.Comments.WithCommentID.Reactions {
    public func reactionID(_ reactionID: String) -> WithReactionID {
        WithReactionID(path: path + "/" + reactionID)
    }

    public struct WithReactionID {
        /// Path: `/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}`
        public let path: String

        /// Delete an issue comment reaction
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/repos/{owner}/{repo}/issues/events`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.Events {
    public func eventID(_ eventID: String) -> WithEventID {
        WithEventID(path: path + "/" + eventID)
    }

    public struct WithEventID {
        /// Path: `/repos/{owner}/{repo}/issues/events/{event_id}`
        public let path: String

        /// Get an issue event
        public func get() -> Request<IssueEvent> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues {
    public func issueNumber(_ issueNumber: String) -> WithIssueNumber {
        WithIssueNumber(path: path + "/" + issueNumber)
    }

    public struct WithIssueNumber {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}`
        public let path: String

        /// Get an issue
        public func get() -> Request<Issue> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber {
    public var assignees: Assignees {
        Assignees(path: path + "/assignees")
    }

    public struct Assignees {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/assignees`
        public let path: String

        /// Remove assignees from an issue
        public func delete() -> Request<Issue> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/comments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/events`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber {
    public var labels: Labels {
        Labels(path: path + "/labels")
    }

    public struct Labels {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/labels`
        public let path: String

        /// Remove all labels from an issue
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber.Labels {
    public func name(_ name: String) -> WithName {
        WithName(path: path + "/" + name)
    }

    public struct WithName {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber {
    public var lock: Lock {
        Lock(path: path + "/lock")
    }

    public struct Lock {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/lock`
        public let path: String

        /// Unlock an issue
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/reactions`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber.Reactions {
    public func reactionID(_ reactionID: String) -> WithReactionID {
        WithReactionID(path: path + "/" + reactionID)
    }

    public struct WithReactionID {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}`
        public let path: String

        /// Delete an issue reaction
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Issues.WithIssueNumber {
    public var timeline: Timeline {
        Timeline(path: path + "/timeline")
    }

    public struct Timeline {
        /// Path: `/repos/{owner}/{repo}/issues/{issue_number}/timeline`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var keys: Keys {
        Keys(path: path + "/keys")
    }

    public struct Keys {
        /// Path: `/repos/{owner}/{repo}/keys`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Keys {
    public func keyID(_ keyID: String) -> WithKeyID {
        WithKeyID(path: path + "/" + keyID)
    }

    public struct WithKeyID {
        /// Path: `/repos/{owner}/{repo}/keys/{key_id}`
        public let path: String

        /// Get a deploy key
        public func get() -> Request<DeployKey> {
            .get(path)
        }

        /// Delete a deploy key
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var labels: Labels {
        Labels(path: path + "/labels")
    }

    public struct Labels {
        /// Path: `/repos/{owner}/{repo}/labels`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Labels {
    public func name(_ name: String) -> WithName {
        WithName(path: path + "/" + name)
    }

    public struct WithName {
        /// Path: `/repos/{owner}/{repo}/labels/{name}`
        public let path: String

        /// Get a label
        public func get() -> Request<Label> {
            .get(path)
        }

        /// Delete a label
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var languages: Languages {
        Languages(path: path + "/languages")
    }

    public struct Languages {
        /// Path: `/repos/{owner}/{repo}/languages`
        public let path: String

        /// List repository languages
        public func get() -> Request<Language> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var lfs: Lfs {
        Lfs(path: path + "/lfs")
    }

    public struct Lfs {
        /// Path: `/repos/{owner}/{repo}/lfs`
        public let path: String

        /// Disable Git LFS for a repository
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var license: License {
        License(path: path + "/license")
    }

    public struct License {
        /// Path: `/repos/{owner}/{repo}/license`
        public let path: String

        /// Get the license for a repository
        public func get() -> Request<LicenseContent> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var mergeUpstream: MergeUpstream {
        MergeUpstream(path: path + "/merge-upstream")
    }

    public struct MergeUpstream {
        /// Path: `/repos/{owner}/{repo}/merge-upstream`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var merges: Merges {
        Merges(path: path + "/merges")
    }

    public struct Merges {
        /// Path: `/repos/{owner}/{repo}/merges`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var milestones: Milestones {
        Milestones(path: path + "/milestones")
    }

    public struct Milestones {
        /// Path: `/repos/{owner}/{repo}/milestones`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Milestones {
    public func milestoneNumber(_ milestoneNumber: String) -> WithMilestoneNumber {
        WithMilestoneNumber(path: path + "/" + milestoneNumber)
    }

    public struct WithMilestoneNumber {
        /// Path: `/repos/{owner}/{repo}/milestones/{milestone_number}`
        public let path: String

        /// Get a milestone
        public func get() -> Request<Milestone> {
            .get(path)
        }

        /// Delete a milestone
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Milestones.WithMilestoneNumber {
    public var labels: Labels {
        Labels(path: path + "/labels")
    }

    public struct Labels {
        /// Path: `/repos/{owner}/{repo}/milestones/{milestone_number}/labels`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var notifications: Notifications {
        Notifications(path: path + "/notifications")
    }

    public struct Notifications {
        /// Path: `/repos/{owner}/{repo}/notifications`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var pages: Pages {
        Pages(path: path + "/pages")
    }

    public struct Pages {
        /// Path: `/repos/{owner}/{repo}/pages`
        public let path: String

        /// Get a GitHub Pages site
        public func get() -> Request<Page> {
            .get(path)
        }

        /// Delete a GitHub Pages site
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pages {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/repos/{owner}/{repo}/pages/builds`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pages.Builds {
    public var latest: Latest {
        Latest(path: path + "/latest")
    }

    public struct Latest {
        /// Path: `/repos/{owner}/{repo}/pages/builds/latest`
        public let path: String

        /// Get latest Pages build
        public func get() -> Request<PageBuild> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pages.Builds {
    public func buildID(_ buildID: String) -> WithBuildID {
        WithBuildID(path: path + "/" + buildID)
    }

    public struct WithBuildID {
        /// Path: `/repos/{owner}/{repo}/pages/builds/{build_id}`
        public let path: String

        /// Get GitHub Pages build
        public func get() -> Request<PageBuild> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pages {
    public var health: Health {
        Health(path: path + "/health")
    }

    public struct Health {
        /// Path: `/repos/{owner}/{repo}/pages/health`
        public let path: String

        /// Get a DNS health check for GitHub Pages
        public func get() -> Request<PagesHealthCheck> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var projects: Projects {
        Projects(path: path + "/projects")
    }

    public struct Projects {
        /// Path: `/repos/{owner}/{repo}/projects`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var pulls: Pulls {
        Pulls(path: path + "/pulls")
    }

    public struct Pulls {
        /// Path: `/repos/{owner}/{repo}/pulls`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/repos/{owner}/{repo}/pulls/comments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.Comments {
    public func commentID(_ commentID: String) -> WithCommentID {
        WithCommentID(path: path + "/" + commentID)
    }

    public struct WithCommentID {
        /// Path: `/repos/{owner}/{repo}/pulls/comments/{comment_id}`
        public let path: String

        /// Get a review comment for a pull request
        public func get() -> Request<PullRequestReviewComment> {
            .get(path)
        }

        /// Delete a review comment for a pull request
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.Comments.WithCommentID {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.Comments.WithCommentID.Reactions {
    public func reactionID(_ reactionID: String) -> WithReactionID {
        WithReactionID(path: path + "/" + reactionID)
    }

    public struct WithReactionID {
        /// Path: `/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}`
        public let path: String

        /// Delete a pull request comment reaction
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls {
    public func pullNumber(_ pullNumber: String) -> WithPullNumber {
        WithPullNumber(path: path + "/" + pullNumber)
    }

    public struct WithPullNumber {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}`
        public let path: String

        /// Get a pull request
        public func get() -> Request<PullRequest> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber {
    public var codespaces: Codespaces {
        Codespaces(path: path + "/codespaces")
    }

    public struct Codespaces {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/codespaces`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/comments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber.Comments {
    public func commentID(_ commentID: String) -> WithCommentID {
        WithCommentID(path: path + "/" + commentID)
    }

    public struct WithCommentID {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber.Comments.WithCommentID {
    public var replies: Replies {
        Replies(path: path + "/replies")
    }

    public struct Replies {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber {
    public var commits: Commits {
        Commits(path: path + "/commits")
    }

    public struct Commits {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/commits`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber {
    public var files: Files {
        Files(path: path + "/files")
    }

    public struct Files {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/files`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber {
    public var merge: Merge {
        Merge(path: path + "/merge")
    }

    public struct Merge {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/merge`
        public let path: String

        /// Check if a pull request has been merged
        public func get() -> Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber {
    public var requestedReviewers: RequestedReviewers {
        RequestedReviewers(path: path + "/requested_reviewers")
    }

    public struct RequestedReviewers {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers`
        public let path: String

        /// List requested reviewers for a pull request
        public func get() -> Request<PullRequestReviewRequest> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        /// Remove requested reviewers from a pull request
        public func delete() -> Request<PullRequestSimple> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber {
    public var reviews: Reviews {
        Reviews(path: path + "/reviews")
    }

    public struct Reviews {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/reviews`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber.Reviews {
    public func reviewID(_ reviewID: String) -> WithReviewID {
        WithReviewID(path: path + "/" + reviewID)
    }

    public struct WithReviewID {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}`
        public let path: String

        /// Get a review for a pull request
        public func get() -> Request<PullRequestReview> {
            .get(path)
        }

        /// Delete a pending review for a pull request
        public func delete() -> Request<PullRequestReview> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber.Reviews.WithReviewID {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber.Reviews.WithReviewID {
    public var dismissals: Dismissals {
        Dismissals(path: path + "/dismissals")
    }

    public struct Dismissals {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber.Reviews.WithReviewID {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Pulls.WithPullNumber {
    public var updateBranch: UpdateBranch {
        UpdateBranch(path: path + "/update-branch")
    }

    public struct UpdateBranch {
        /// Path: `/repos/{owner}/{repo}/pulls/{pull_number}/update-branch`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var readme: Readme {
        Readme(path: path + "/readme")
    }

    public struct Readme {
        /// Path: `/repos/{owner}/{repo}/readme`
        public let path: String

        /// Get a repository README
        public func get() -> Request<ContentFile> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Readme {
    public func dir(_ dir: String) -> WithDir {
        WithDir(path: path + "/" + dir)
    }

    public struct WithDir {
        /// Path: `/repos/{owner}/{repo}/readme/{dir}`
        public let path: String

        /// Get a repository README for a directory
        public func get() -> Request<ContentFile> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/repos/{owner}/{repo}/releases`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases {
    public var assets: Assets {
        Assets(path: path + "/assets")
    }

    public struct Assets {
        /// Path: `/repos/{owner}/{repo}/releases/assets`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases.Assets {
    public func assetID(_ assetID: String) -> WithAssetID {
        WithAssetID(path: path + "/" + assetID)
    }

    public struct WithAssetID {
        /// Path: `/repos/{owner}/{repo}/releases/assets/{asset_id}`
        public let path: String

        /// Get a release asset
        public func get() -> Request<ReleaseAsset> {
            .get(path)
        }

        /// Delete a release asset
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases {
    public var generateNotes: GenerateNotes {
        GenerateNotes(path: path + "/generate-notes")
    }

    public struct GenerateNotes {
        /// Path: `/repos/{owner}/{repo}/releases/generate-notes`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases {
    public var latest: Latest {
        Latest(path: path + "/latest")
    }

    public struct Latest {
        /// Path: `/repos/{owner}/{repo}/releases/latest`
        public let path: String

        /// Get the latest release
        public func get() -> Request<Release> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases {
    public var tags: Tags {
        Tags(path: path + "/tags")
    }

    public struct Tags {
        /// Path: `/repos/{owner}/{repo}/releases/tags`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases.Tags {
    public func tag(_ tag: String) -> WithTag {
        WithTag(path: path + "/" + tag)
    }

    public struct WithTag {
        /// Path: `/repos/{owner}/{repo}/releases/tags/{tag}`
        public let path: String

        /// Get a release by tag name
        public func get() -> Request<Release> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases {
    public func releaseID(_ releaseID: String) -> WithReleaseID {
        WithReleaseID(path: path + "/" + releaseID)
    }

    public struct WithReleaseID {
        /// Path: `/repos/{owner}/{repo}/releases/{release_id}`
        public let path: String

        /// Get a release
        public func get() -> Request<Release> {
            .get(path)
        }

        /// Delete a release
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases.WithReleaseID {
    public var assets: Assets {
        Assets(path: path + "/assets")
    }

    public struct Assets {
        /// Path: `/repos/{owner}/{repo}/releases/{release_id}/assets`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Releases.WithReleaseID {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/repos/{owner}/{repo}/releases/{release_id}/reactions`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var secretScanning: SecretScanning {
        SecretScanning(path: path + "/secret-scanning")
    }

    public struct SecretScanning {
        /// Path: `/repos/{owner}/{repo}/secret-scanning`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.SecretScanning {
    public var alerts: Alerts {
        Alerts(path: path + "/alerts")
    }

    public struct Alerts {
        /// Path: `/repos/{owner}/{repo}/secret-scanning/alerts`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.SecretScanning.Alerts {
    public func alertNumber(_ alertNumber: String) -> WithAlertNumber {
        WithAlertNumber(path: path + "/" + alertNumber)
    }

    public struct WithAlertNumber {
        /// Path: `/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}`
        public let path: String

        /// Get a secret scanning alert
        public func get() -> Request<SecretScanningAlert> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var stargazers: Stargazers {
        Stargazers(path: path + "/stargazers")
    }

    public struct Stargazers {
        /// Path: `/repos/{owner}/{repo}/stargazers`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var stats: Stats {
        Stats(path: path + "/stats")
    }

    public struct Stats {
        /// Path: `/repos/{owner}/{repo}/stats`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Stats {
    public var codeFrequency: CodeFrequency {
        CodeFrequency(path: path + "/code_frequency")
    }

    public struct CodeFrequency {
        /// Path: `/repos/{owner}/{repo}/stats/code_frequency`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Stats {
    public var commitActivity: CommitActivity {
        CommitActivity(path: path + "/commit_activity")
    }

    public struct CommitActivity {
        /// Path: `/repos/{owner}/{repo}/stats/commit_activity`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Stats {
    public var contributors: Contributors {
        Contributors(path: path + "/contributors")
    }

    public struct Contributors {
        /// Path: `/repos/{owner}/{repo}/stats/contributors`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Stats {
    public var participation: Participation {
        Participation(path: path + "/participation")
    }

    public struct Participation {
        /// Path: `/repos/{owner}/{repo}/stats/participation`
        public let path: String

        /// Get the weekly commit count
        public func get() -> Request<ParticipationStats> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Stats {
    public var punchCard: PunchCard {
        PunchCard(path: path + "/punch_card")
    }

    public struct PunchCard {
        /// Path: `/repos/{owner}/{repo}/stats/punch_card`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var statuses: Statuses {
        Statuses(path: path + "/statuses")
    }

    public struct Statuses {
        /// Path: `/repos/{owner}/{repo}/statuses`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Statuses {
    public func sha(_ sha: String) -> WithSha {
        WithSha(path: path + "/" + sha)
    }

    public struct WithSha {
        /// Path: `/repos/{owner}/{repo}/statuses/{sha}`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var subscribers: Subscribers {
        Subscribers(path: path + "/subscribers")
    }

    public struct Subscribers {
        /// Path: `/repos/{owner}/{repo}/subscribers`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var subscription: Subscription {
        Subscription(path: path + "/subscription")
    }

    public struct Subscription {
        /// Path: `/repos/{owner}/{repo}/subscription`
        public let path: String

        /// Get a repository subscription
        public func get() -> Request<RepositorySubscription> {
            .get(path)
        }

        /// Delete a repository subscription
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var tags: Tags {
        Tags(path: path + "/tags")
    }

    public struct Tags {
        /// Path: `/repos/{owner}/{repo}/tags`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var tarball: Tarball {
        Tarball(path: path + "/tarball")
    }

    public struct Tarball {
        /// Path: `/repos/{owner}/{repo}/tarball`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Tarball {
    public func ref(_ ref: String) -> WithRef {
        WithRef(path: path + "/" + ref)
    }

    public struct WithRef {
        /// Path: `/repos/{owner}/{repo}/tarball/{ref}`
        public let path: String

        /// Download a repository archive (tar)
        public func get() -> Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/repos/{owner}/{repo}/teams`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var topics: Topics {
        Topics(path: path + "/topics")
    }

    public struct Topics {
        /// Path: `/repos/{owner}/{repo}/topics`
        public let path: String

        /// Get all repository topics
        public func get() -> Request<Topic> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var traffic: Traffic {
        Traffic(path: path + "/traffic")
    }

    public struct Traffic {
        /// Path: `/repos/{owner}/{repo}/traffic`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Traffic {
    public var clones: Clones {
        Clones(path: path + "/clones")
    }

    public struct Clones {
        /// Path: `/repos/{owner}/{repo}/traffic/clones`
        public let path: String

        /// Get repository clones
        public func get() -> Request<CloneTraffic> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo.Traffic {
    public var popular: Popular {
        Popular(path: path + "/popular")
    }

    public struct Popular {
        /// Path: `/repos/{owner}/{repo}/traffic/popular`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Traffic.Popular {
    public var paths: Paths {
        Paths(path: path + "/paths")
    }

    public struct Paths {
        /// Path: `/repos/{owner}/{repo}/traffic/popular/paths`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Traffic.Popular {
    public var referrers: Referrers {
        Referrers(path: path + "/referrers")
    }

    public struct Referrers {
        /// Path: `/repos/{owner}/{repo}/traffic/popular/referrers`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo.Traffic {
    public var views: Views {
        Views(path: path + "/views")
    }

    public struct Views {
        /// Path: `/repos/{owner}/{repo}/traffic/views`
        public let path: String

        /// Get page views
        public func get() -> Request<ViewTraffic> {
            .get(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var transfer: Transfer {
        Transfer(path: path + "/transfer")
    }

    public struct Transfer {
        /// Path: `/repos/{owner}/{repo}/transfer`
        public let path: String


    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var vulnerabilityAlerts: VulnerabilityAlerts {
        VulnerabilityAlerts(path: path + "/vulnerability-alerts")
    }

    public struct VulnerabilityAlerts {
        /// Path: `/repos/{owner}/{repo}/vulnerability-alerts`
        public let path: String

        /// Check if vulnerability alerts are enabled for a repository
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Disable vulnerability alerts
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Repos.WithOwner.WithRepo {
    public var zipball: Zipball {
        Zipball(path: path + "/zipball")
    }

    public struct Zipball {
        /// Path: `/repos/{owner}/{repo}/zipball`
        public let path: String
    }
}

extension Paths.Repos.WithOwner.WithRepo.Zipball {
    public func ref(_ ref: String) -> WithRef {
        WithRef(path: path + "/" + ref)
    }

    public struct WithRef {
        /// Path: `/repos/{owner}/{repo}/zipball/{ref}`
        public let path: String

        /// Download a repository archive (zip)
        public func get() -> Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Repos {
    public func templateOwner(_ templateOwner: String) -> WithTemplateOwner {
        WithTemplateOwner(path: path + "/" + templateOwner)
    }

    public struct WithTemplateOwner {
        /// Path: `/repos/{template_owner}`
        public let path: String
    }
}

extension Paths.Repos.WithTemplateOwner {
    public func templateRepo(_ templateRepo: String) -> WithTemplateRepo {
        WithTemplateRepo(path: path + "/" + templateRepo)
    }

    public struct WithTemplateRepo {
        /// Path: `/repos/{template_owner}/{template_repo}`
        public let path: String
    }
}

extension Paths.Repos.WithTemplateOwner.WithTemplateRepo {
    public var generate: Generate {
        Generate(path: path + "/generate")
    }

    public struct Generate {
        /// Path: `/repos/{template_owner}/{template_repo}/generate`
        public let path: String


    }
}

extension Paths {
    public static var repositories: Repositories {
        Repositories(path: "/repositories")
    }

    public struct Repositories {
        /// Path: `/repositories`
        public let path: String


    }
}

extension Paths.Repositories {
    public func repositoryID(_ repositoryID: String) -> WithRepositoryID {
        WithRepositoryID(path: path + "/" + repositoryID)
    }

    public struct WithRepositoryID {
        /// Path: `/repositories/{repository_id}`
        public let path: String
    }
}

extension Paths.Repositories.WithRepositoryID {
    public var environments: Environments {
        Environments(path: path + "/environments")
    }

    public struct Environments {
        /// Path: `/repositories/{repository_id}/environments`
        public let path: String
    }
}

extension Paths.Repositories.WithRepositoryID.Environments {
    public func environmentName(_ environmentName: String) -> WithEnvironmentName {
        WithEnvironmentName(path: path + "/" + environmentName)
    }

    public struct WithEnvironmentName {
        /// Path: `/repositories/{repository_id}/environments/{environment_name}`
        public let path: String
    }
}

extension Paths.Repositories.WithRepositoryID.Environments.WithEnvironmentName {
    public var secrets: Secrets {
        Secrets(path: path + "/secrets")
    }

    public struct Secrets {
        /// Path: `/repositories/{repository_id}/environments/{environment_name}/secrets`
        public let path: String

        /// List environment secrets
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var secrets: [OctoKit.ActionsSecret]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.secrets = try values.decode([OctoKit.ActionsSecret].self, forKey: "secrets")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(secrets, forKey: "secrets")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Repositories.WithRepositoryID.Environments.WithEnvironmentName.Secrets {
    public var publicKey: PublicKey {
        PublicKey(path: path + "/public-key")
    }

    public struct PublicKey {
        /// Path: `/repositories/{repository_id}/environments/{environment_name}/secrets/public-key`
        public let path: String

        /// Get an environment public key
        public func get() -> Request<ActionsPublicKey> {
            .get(path)
        }
    }
}

extension Paths.Repositories.WithRepositoryID.Environments.WithEnvironmentName.Secrets {
    public func secretName(_ secretName: String) -> WithSecretName {
        WithSecretName(path: path + "/" + secretName)
    }

    public struct WithSecretName {
        /// Path: `/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}`
        public let path: String

        /// Get an environment secret
        public func get() -> Request<ActionsSecret> {
            .get(path)
        }

        /// Delete an environment secret
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var scim: Scim {
        Scim(path: "/scim")
    }

    public struct Scim {
        /// Path: `/scim`
        public let path: String
    }
}

extension Paths.Scim {
    public var v2: V2 {
        V2(path: path + "/v2")
    }

    public struct V2 {
        /// Path: `/scim/v2`
        public let path: String
    }
}

extension Paths.Scim.V2 {
    public var enterprises: Enterprises {
        Enterprises(path: path + "/enterprises")
    }

    public struct Enterprises {
        /// Path: `/scim/v2/enterprises`
        public let path: String
    }
}

extension Paths.Scim.V2.Enterprises {
    public func enterprise(_ enterprise: String) -> WithEnterprise {
        WithEnterprise(path: path + "/" + enterprise)
    }

    public struct WithEnterprise {
        /// Path: `/scim/v2/enterprises/{enterprise}`
        public let path: String
    }
}

extension Paths.Scim.V2.Enterprises.WithEnterprise {
    public var groups: Groups {
        Groups(path: path + "/Groups")
    }

    public struct Groups {
        /// Path: `/scim/v2/enterprises/{enterprise}/Groups`
        public let path: String

        /// List provisioned SCIM groups for an enterprise
        public func get() -> Request<ScimGroupListEnterprise> {
            .get(path)
        }
    }
}

extension Paths.Scim.V2.Enterprises.WithEnterprise.Groups {
    public func scimGroupID(_ scimGroupID: String) -> WithScimGroupID {
        WithScimGroupID(path: path + "/" + scimGroupID)
    }

    public struct WithScimGroupID {
        /// Path: `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}`
        public let path: String

        /// Get SCIM provisioning information for an enterprise group
        public func get() -> Request<ScimEnterpriseGroup> {
            .get(path)
        }

        /// Delete a SCIM group from an enterprise
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Scim.V2.Enterprises.WithEnterprise {
    public var users: Users {
        Users(path: path + "/Users")
    }

    public struct Users {
        /// Path: `/scim/v2/enterprises/{enterprise}/Users`
        public let path: String

        /// List SCIM provisioned identities for an enterprise
        public func get() -> Request<ScimUserListEnterprise> {
            .get(path)
        }
    }
}

extension Paths.Scim.V2.Enterprises.WithEnterprise.Users {
    public func scimUserID(_ scimUserID: String) -> WithScimUserID {
        WithScimUserID(path: path + "/" + scimUserID)
    }

    public struct WithScimUserID {
        /// Path: `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}`
        public let path: String

        /// Get SCIM provisioning information for an enterprise user
        public func get() -> Request<ScimEnterpriseUser> {
            .get(path)
        }

        /// Delete a SCIM user from an enterprise
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Scim.V2 {
    public var organizations: Organizations {
        Organizations(path: path + "/organizations")
    }

    public struct Organizations {
        /// Path: `/scim/v2/organizations`
        public let path: String
    }
}

extension Paths.Scim.V2.Organizations {
    public func org(_ org: String) -> WithOrg {
        WithOrg(path: path + "/" + org)
    }

    public struct WithOrg {
        /// Path: `/scim/v2/organizations/{org}`
        public let path: String
    }
}

extension Paths.Scim.V2.Organizations.WithOrg {
    public var users: Users {
        Users(path: path + "/Users")
    }

    public struct Users {
        /// Path: `/scim/v2/organizations/{org}/Users`
        public let path: String


    }
}

extension Paths.Scim.V2.Organizations.WithOrg.Users {
    public func scimUserID(_ scimUserID: String) -> WithScimUserID {
        WithScimUserID(path: path + "/" + scimUserID)
    }

    public struct WithScimUserID {
        /// Path: `/scim/v2/organizations/{org}/Users/{scim_user_id}`
        public let path: String

        /// Delete a SCIM user from an organization
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var search: Search {
        Search(path: "/search")
    }

    public struct Search {
        /// Path: `/search`
        public let path: String
    }
}

extension Paths.Search {
    public var code: Code {
        Code(path: path + "/code")
    }

    public struct Code {
        /// Path: `/search/code`
        public let path: String

        /// Search code
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var isIncompleteResults: Bool
            public var items: [OctoKit.CodeSearchResultItem]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isIncompleteResults = try values.decode(Bool.self, forKey: "incomplete_results")
                self.items = try values.decode([OctoKit.CodeSearchResultItem].self, forKey: "items")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(isIncompleteResults, forKey: "incomplete_results")
                try values.encode(items, forKey: "items")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Search {
    public var commits: Commits {
        Commits(path: path + "/commits")
    }

    public struct Commits {
        /// Path: `/search/commits`
        public let path: String

        /// Search commits
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var isIncompleteResults: Bool
            public var items: [OctoKit.CommitSearchResultItem]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isIncompleteResults = try values.decode(Bool.self, forKey: "incomplete_results")
                self.items = try values.decode([OctoKit.CommitSearchResultItem].self, forKey: "items")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(isIncompleteResults, forKey: "incomplete_results")
                try values.encode(items, forKey: "items")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Search {
    public var issues: Issues {
        Issues(path: path + "/issues")
    }

    public struct Issues {
        /// Path: `/search/issues`
        public let path: String

        /// Search issues and pull requests
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var isIncompleteResults: Bool
            public var items: [OctoKit.IssueSearchResultItem]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isIncompleteResults = try values.decode(Bool.self, forKey: "incomplete_results")
                self.items = try values.decode([OctoKit.IssueSearchResultItem].self, forKey: "items")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(isIncompleteResults, forKey: "incomplete_results")
                try values.encode(items, forKey: "items")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Search {
    public var labels: Labels {
        Labels(path: path + "/labels")
    }

    public struct Labels {
        /// Path: `/search/labels`
        public let path: String

        /// Search labels
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var isIncompleteResults: Bool
            public var items: [OctoKit.LabelSearchResultItem]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isIncompleteResults = try values.decode(Bool.self, forKey: "incomplete_results")
                self.items = try values.decode([OctoKit.LabelSearchResultItem].self, forKey: "items")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(isIncompleteResults, forKey: "incomplete_results")
                try values.encode(items, forKey: "items")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Search {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/search/repositories`
        public let path: String

        /// Search repositories
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var isIncompleteResults: Bool
            public var items: [OctoKit.RepoSearchResultItem]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isIncompleteResults = try values.decode(Bool.self, forKey: "incomplete_results")
                self.items = try values.decode([OctoKit.RepoSearchResultItem].self, forKey: "items")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(isIncompleteResults, forKey: "incomplete_results")
                try values.encode(items, forKey: "items")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Search {
    public var topics: Topics {
        Topics(path: path + "/topics")
    }

    public struct Topics {
        /// Path: `/search/topics`
        public let path: String

        /// Search topics
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var isIncompleteResults: Bool
            public var items: [OctoKit.TopicSearchResultItem]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isIncompleteResults = try values.decode(Bool.self, forKey: "incomplete_results")
                self.items = try values.decode([OctoKit.TopicSearchResultItem].self, forKey: "items")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(isIncompleteResults, forKey: "incomplete_results")
                try values.encode(items, forKey: "items")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.Search {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/search/users`
        public let path: String

        /// Search users
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var isIncompleteResults: Bool
            public var items: [OctoKit.UserSearchResultItem]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isIncompleteResults = try values.decode(Bool.self, forKey: "incomplete_results")
                self.items = try values.decode([OctoKit.UserSearchResultItem].self, forKey: "items")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(isIncompleteResults, forKey: "incomplete_results")
                try values.encode(items, forKey: "items")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths {
    public static var teams: Teams {
        Teams(path: "/teams")
    }

    public struct Teams {
        /// Path: `/teams`
        public let path: String
    }
}

extension Paths.Teams {
    public func teamID(_ teamID: String) -> WithTeamID {
        WithTeamID(path: path + "/" + teamID)
    }

    public struct WithTeamID {
        /// Path: `/teams/{team_id}`
        public let path: String

        /// Get a team (Legacy)
        public func get() -> Request<TeamFull> {
            .get(path)
        }

        /// Delete a team (Legacy)
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Teams.WithTeamID {
    public var discussions: Discussions {
        Discussions(path: path + "/discussions")
    }

    public struct Discussions {
        /// Path: `/teams/{team_id}/discussions`
        public let path: String


    }
}

extension Paths.Teams.WithTeamID.Discussions {
    public func discussionNumber(_ discussionNumber: String) -> WithDiscussionNumber {
        WithDiscussionNumber(path: path + "/" + discussionNumber)
    }

    public struct WithDiscussionNumber {
        /// Path: `/teams/{team_id}/discussions/{discussion_number}`
        public let path: String

        /// Get a discussion (Legacy)
        public func get() -> Request<TeamDiscussion> {
            .get(path)
        }

        /// Delete a discussion (Legacy)
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Teams.WithTeamID.Discussions.WithDiscussionNumber {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/teams/{team_id}/discussions/{discussion_number}/comments`
        public let path: String


    }
}

extension Paths.Teams.WithTeamID.Discussions.WithDiscussionNumber.Comments {
    public func commentNumber(_ commentNumber: String) -> WithCommentNumber {
        WithCommentNumber(path: path + "/" + commentNumber)
    }

    public struct WithCommentNumber {
        /// Path: `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}`
        public let path: String

        /// Get a discussion comment (Legacy)
        public func get() -> Request<TeamDiscussionComment> {
            .get(path)
        }

        /// Delete a discussion comment (Legacy)
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Teams.WithTeamID.Discussions.WithDiscussionNumber.Comments.WithCommentNumber {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions`
        public let path: String


    }
}

extension Paths.Teams.WithTeamID.Discussions.WithDiscussionNumber {
    public var reactions: Reactions {
        Reactions(path: path + "/reactions")
    }

    public struct Reactions {
        /// Path: `/teams/{team_id}/discussions/{discussion_number}/reactions`
        public let path: String


    }
}

extension Paths.Teams.WithTeamID {
    public var invitations: Invitations {
        Invitations(path: path + "/invitations")
    }

    public struct Invitations {
        /// Path: `/teams/{team_id}/invitations`
        public let path: String


    }
}

extension Paths.Teams.WithTeamID {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/teams/{team_id}/members`
        public let path: String


    }
}

extension Paths.Teams.WithTeamID.Members {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/teams/{team_id}/members/{username}`
        public let path: String

        /// Get team member (Legacy)
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Remove team member (Legacy)
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Teams.WithTeamID {
    public var memberships: Memberships {
        Memberships(path: path + "/memberships")
    }

    public struct Memberships {
        /// Path: `/teams/{team_id}/memberships`
        public let path: String
    }
}

extension Paths.Teams.WithTeamID.Memberships {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/teams/{team_id}/memberships/{username}`
        public let path: String

        /// Get team membership for a user (Legacy)
        public func get() -> Request<TeamMembership> {
            .get(path)
        }

        /// Remove team membership for a user (Legacy)
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Teams.WithTeamID {
    public var projects: Projects {
        Projects(path: path + "/projects")
    }

    public struct Projects {
        /// Path: `/teams/{team_id}/projects`
        public let path: String


    }
}

extension Paths.Teams.WithTeamID.Projects {
    public func projectID(_ projectID: String) -> WithProjectID {
        WithProjectID(path: path + "/" + projectID)
    }

    public struct WithProjectID {
        /// Path: `/teams/{team_id}/projects/{project_id}`
        public let path: String

        /// Check team permissions for a project (Legacy)
        public func get() -> Request<TeamProject> {
            .get(path)
        }

        /// Remove a project from a team (Legacy)
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Teams.WithTeamID {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/teams/{team_id}/repos`
        public let path: String


    }
}

extension Paths.Teams.WithTeamID.Repos {
    public func owner(_ owner: String) -> WithOwner {
        WithOwner(path: path + "/" + owner)
    }

    public struct WithOwner {
        /// Path: `/teams/{team_id}/repos/{owner}`
        public let path: String
    }
}

extension Paths.Teams.WithTeamID.Repos.WithOwner {
    public func repo(_ repo: String) -> WithRepo {
        WithRepo(path: path + "/" + repo)
    }

    public struct WithRepo {
        /// Path: `/teams/{team_id}/repos/{owner}/{repo}`
        public let path: String

        /// Check team permissions for a repository (Legacy)
        public func get() -> Request<TeamRepository> {
            .get(path)
        }

        /// Remove a repository from a team (Legacy)
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Teams.WithTeamID {
    public var teamSync: TeamSync {
        TeamSync(path: path + "/team-sync")
    }

    public struct TeamSync {
        /// Path: `/teams/{team_id}/team-sync`
        public let path: String
    }
}

extension Paths.Teams.WithTeamID.TeamSync {
    public var groupMappings: GroupMappings {
        GroupMappings(path: path + "/group-mappings")
    }

    public struct GroupMappings {
        /// Path: `/teams/{team_id}/team-sync/group-mappings`
        public let path: String

        /// List IdP groups for a team (Legacy)
        public func get() -> Request<GroupMapping> {
            .get(path)
        }
    }
}

extension Paths.Teams.WithTeamID {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/teams/{team_id}/teams`
        public let path: String


    }
}

extension Paths {
    public static var user: User {
        User(path: "/user")
    }

    public struct User {
        /// Path: `/user`
        public let path: String


    }
}

extension Paths.User {
    public var blocks: Blocks {
        Blocks(path: path + "/blocks")
    }

    public struct Blocks {
        /// Path: `/user/blocks`
        public let path: String


    }
}

extension Paths.User.Blocks {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/user/blocks/{username}`
        public let path: String

        /// Check if a user is blocked by the authenticated user
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Unblock a user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var codespaces: Codespaces {
        Codespaces(path: path + "/codespaces")
    }

    public struct Codespaces {
        /// Path: `/user/codespaces`
        public let path: String

        /// List codespaces for the authenticated user
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var codespaces: [OctoKit.Codespace]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.codespaces = try values.decode([OctoKit.Codespace].self, forKey: "codespaces")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(codespaces, forKey: "codespaces")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.User.Codespaces {
    public var secrets: Secrets {
        Secrets(path: path + "/secrets")
    }

    public struct Secrets {
        /// Path: `/user/codespaces/secrets`
        public let path: String

        /// List secrets for the authenticated user
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var secrets: [OctoKit.CodespacesSecret]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.secrets = try values.decode([OctoKit.CodespacesSecret].self, forKey: "secrets")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(secrets, forKey: "secrets")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.User.Codespaces.Secrets {
    public var publicKey: PublicKey {
        PublicKey(path: path + "/public-key")
    }

    public struct PublicKey {
        /// Path: `/user/codespaces/secrets/public-key`
        public let path: String

        /// Get public key for the authenticated user
        public func get() -> Request<CodespacesUserPublicKey> {
            .get(path)
        }
    }
}

extension Paths.User.Codespaces.Secrets {
    public func secretName(_ secretName: String) -> WithSecretName {
        WithSecretName(path: path + "/" + secretName)
    }

    public struct WithSecretName {
        /// Path: `/user/codespaces/secrets/{secret_name}`
        public let path: String

        /// Get a secret for the authenticated user
        public func get() -> Request<CodespacesSecret> {
            .get(path)
        }

        /// Delete a secret for the authenticated user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User.Codespaces.Secrets.WithSecretName {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/user/codespaces/secrets/{secret_name}/repositories`
        public let path: String

        /// List selected repositories for a user secret
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var repositories: [OctoKit.MinimalRepository]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.repositories = try values.decode([OctoKit.MinimalRepository].self, forKey: "repositories")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(repositories, forKey: "repositories")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.User.Codespaces.Secrets.WithSecretName.Repositories {
    public func repositoryID(_ repositoryID: String) -> WithRepositoryID {
        WithRepositoryID(path: path + "/" + repositoryID)
    }

    public struct WithRepositoryID {
        /// Path: `/user/codespaces/secrets/{secret_name}/repositories/{repository_id}`
        public let path: String

        /// Remove a selected repository from a user secret
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User.Codespaces {
    public func codespaceName(_ codespaceName: String) -> WithCodespaceName {
        WithCodespaceName(path: path + "/" + codespaceName)
    }

    public struct WithCodespaceName {
        /// Path: `/user/codespaces/{codespace_name}`
        public let path: String

        /// Get a codespace for the authenticated user
        public func get() -> Request<Codespace> {
            .get(path)
        }
    }
}

extension Paths.User.Codespaces.WithCodespaceName {
    public var machines: Machines {
        Machines(path: path + "/machines")
    }

    public struct Machines {
        /// Path: `/user/codespaces/{codespace_name}/machines`
        public let path: String

        /// List machine types for a codespace
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Codable {
            public var machines: [OctoKit.CodespaceMachine]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.machines = try values.decode([OctoKit.CodespaceMachine].self, forKey: "machines")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(machines, forKey: "machines")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.User.Codespaces.WithCodespaceName {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/user/codespaces/{codespace_name}/start`
        public let path: String


    }
}

extension Paths.User.Codespaces.WithCodespaceName {
    public var stop: Stop {
        Stop(path: path + "/stop")
    }

    public struct Stop {
        /// Path: `/user/codespaces/{codespace_name}/stop`
        public let path: String


    }
}

extension Paths.User {
    public var email: Email {
        Email(path: path + "/email")
    }

    public struct Email {
        /// Path: `/user/email`
        public let path: String
    }
}

extension Paths.User.Email {
    public var visibility: Visibility {
        Visibility(path: path + "/visibility")
    }

    public struct Visibility {
        /// Path: `/user/email/visibility`
        public let path: String


    }
}

extension Paths.User {
    public var emails: Emails {
        Emails(path: path + "/emails")
    }

    public struct Emails {
        /// Path: `/user/emails`
        public let path: String

        /// Delete an email address for the authenticated user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/user/followers`
        public let path: String


    }
}

extension Paths.User {
    public var following: Following {
        Following(path: path + "/following")
    }

    public struct Following {
        /// Path: `/user/following`
        public let path: String


    }
}

extension Paths.User.Following {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/user/following/{username}`
        public let path: String

        /// Check if a person is followed by the authenticated user
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Unfollow a user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var gpgKeys: GpgKeys {
        GpgKeys(path: path + "/gpg_keys")
    }

    public struct GpgKeys {
        /// Path: `/user/gpg_keys`
        public let path: String


    }
}

extension Paths.User.GpgKeys {
    public func gpgKeyID(_ gpgKeyID: String) -> WithGpgKeyID {
        WithGpgKeyID(path: path + "/" + gpgKeyID)
    }

    public struct WithGpgKeyID {
        /// Path: `/user/gpg_keys/{gpg_key_id}`
        public let path: String

        /// Get a GPG key for the authenticated user
        public func get() -> Request<GpgKey> {
            .get(path)
        }

        /// Delete a GPG key for the authenticated user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var installations: Installations {
        Installations(path: path + "/installations")
    }

    public struct Installations {
        /// Path: `/user/installations`
        public let path: String

        /// List app installations accessible to the user access token
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var installations: [OctoKit.Installation]
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.installations = try values.decode([OctoKit.Installation].self, forKey: "installations")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(installations, forKey: "installations")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.User.Installations {
    public func installationID(_ installationID: String) -> WithInstallationID {
        WithInstallationID(path: path + "/" + installationID)
    }

    public struct WithInstallationID {
        /// Path: `/user/installations/{installation_id}`
        public let path: String
    }
}

extension Paths.User.Installations.WithInstallationID {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/user/installations/{installation_id}/repositories`
        public let path: String

        /// List repositories accessible to the user access token
        public func get() -> Request<GetResponse> {
            .get(path)
        }

        public enum GetHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetResponse: Codable {
            public var repositories: [OctoKit.Repository]
            public var repositorySelection: String?
            public var totalCount: Int

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.repositories = try values.decode([OctoKit.Repository].self, forKey: "repositories")
                self.repositorySelection = try values.decodeIfPresent(String.self, forKey: "repository_selection")
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(repositories, forKey: "repositories")
                try values.encodeIfPresent(repositorySelection, forKey: "repository_selection")
                try values.encode(totalCount, forKey: "total_count")
            }
        }
    }
}

extension Paths.User.Installations.WithInstallationID.Repositories {
    public func repositoryID(_ repositoryID: String) -> WithRepositoryID {
        WithRepositoryID(path: path + "/" + repositoryID)
    }

    public struct WithRepositoryID {
        /// Path: `/user/installations/{installation_id}/repositories/{repository_id}`
        public let path: String

        /// Remove a repository from an app installation
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var interactionLimits: InteractionLimits {
        InteractionLimits(path: path + "/interaction-limits")
    }

    public struct InteractionLimits {
        /// Path: `/user/interaction-limits`
        public let path: String

        /// Set interaction restrictions for your public repositories
        public func put(_ body: InteractionLimit) -> Request<InteractionLimitResponse> {
            .put(path, body: body)
        }

        /// Remove interaction restrictions from your public repositories
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var issues: Issues {
        Issues(path: path + "/issues")
    }

    public struct Issues {
        /// Path: `/user/issues`
        public let path: String


    }
}

extension Paths.User {
    public var keys: Keys {
        Keys(path: path + "/keys")
    }

    public struct Keys {
        /// Path: `/user/keys`
        public let path: String


    }
}

extension Paths.User.Keys {
    public func keyID(_ keyID: String) -> WithKeyID {
        WithKeyID(path: path + "/" + keyID)
    }

    public struct WithKeyID {
        /// Path: `/user/keys/{key_id}`
        public let path: String

        /// Get a public SSH key for the authenticated user
        public func get() -> Request<Key> {
            .get(path)
        }

        /// Delete a public SSH key for the authenticated user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var marketplacePurchases: MarketplacePurchases {
        MarketplacePurchases(path: path + "/marketplace_purchases")
    }

    public struct MarketplacePurchases {
        /// Path: `/user/marketplace_purchases`
        public let path: String


    }
}

extension Paths.User.MarketplacePurchases {
    public var stubbed: Stubbed {
        Stubbed(path: path + "/stubbed")
    }

    public struct Stubbed {
        /// Path: `/user/marketplace_purchases/stubbed`
        public let path: String


    }
}

extension Paths.User {
    public var memberships: Memberships {
        Memberships(path: path + "/memberships")
    }

    public struct Memberships {
        /// Path: `/user/memberships`
        public let path: String
    }
}

extension Paths.User.Memberships {
    public var orgs: Orgs {
        Orgs(path: path + "/orgs")
    }

    public struct Orgs {
        /// Path: `/user/memberships/orgs`
        public let path: String


    }
}

extension Paths.User.Memberships.Orgs {
    public func org(_ org: String) -> WithOrg {
        WithOrg(path: path + "/" + org)
    }

    public struct WithOrg {
        /// Path: `/user/memberships/orgs/{org}`
        public let path: String

        /// Get an organization membership for the authenticated user
        public func get() -> Request<OrgMembership> {
            .get(path)
        }
    }
}

extension Paths.User {
    public var migrations: Migrations {
        Migrations(path: path + "/migrations")
    }

    public struct Migrations {
        /// Path: `/user/migrations`
        public let path: String


    }
}

extension Paths.User.Migrations {
    public func migrationID(_ migrationID: String) -> WithMigrationID {
        WithMigrationID(path: path + "/" + migrationID)
    }

    public struct WithMigrationID {
        /// Path: `/user/migrations/{migration_id}`
        public let path: String

        /// Get a user migration status
        public func get() -> Request<Migration> {
            .get(path)
        }
    }
}

extension Paths.User.Migrations.WithMigrationID {
    public var archive: Archive {
        Archive(path: path + "/archive")
    }

    public struct Archive {
        /// Path: `/user/migrations/{migration_id}/archive`
        public let path: String

        /// Download a user migration archive
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Delete a user migration archive
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User.Migrations.WithMigrationID {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/user/migrations/{migration_id}/repos`
        public let path: String
    }
}

extension Paths.User.Migrations.WithMigrationID.Repos {
    public func repoName(_ repoName: String) -> WithRepoName {
        WithRepoName(path: path + "/" + repoName)
    }

    public struct WithRepoName {
        /// Path: `/user/migrations/{migration_id}/repos/{repo_name}`
        public let path: String
    }
}

extension Paths.User.Migrations.WithMigrationID.Repos.WithRepoName {
    public var lock: Lock {
        Lock(path: path + "/lock")
    }

    public struct Lock {
        /// Path: `/user/migrations/{migration_id}/repos/{repo_name}/lock`
        public let path: String

        /// Unlock a user repository
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User.Migrations.WithMigrationID {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/user/migrations/{migration_id}/repositories`
        public let path: String


    }
}

extension Paths.User {
    public var orgs: Orgs {
        Orgs(path: path + "/orgs")
    }

    public struct Orgs {
        /// Path: `/user/orgs`
        public let path: String


    }
}

extension Paths.User {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/user/packages`
        public let path: String


    }
}

extension Paths.User.Packages {
    public func packageType(_ packageType: String) -> WithPackageType {
        WithPackageType(path: path + "/" + packageType)
    }

    public struct WithPackageType {
        /// Path: `/user/packages/{package_type}`
        public let path: String
    }
}

extension Paths.User.Packages.WithPackageType {
    public func packageName(_ packageName: String) -> WithPackageName {
        WithPackageName(path: path + "/" + packageName)
    }

    public struct WithPackageName {
        /// Path: `/user/packages/{package_type}/{package_name}`
        public let path: String

        /// Get a package for the authenticated user
        public func get() -> Request<Package> {
            .get(path)
        }

        /// Delete a package for the authenticated user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User.Packages.WithPackageType.WithPackageName {
    public var restore: Restore {
        Restore(path: path + "/restore")
    }

    public struct Restore {
        /// Path: `/user/packages/{package_type}/{package_name}/restore`
        public let path: String


    }
}

extension Paths.User.Packages.WithPackageType.WithPackageName {
    public var versions: Versions {
        Versions(path: path + "/versions")
    }

    public struct Versions {
        /// Path: `/user/packages/{package_type}/{package_name}/versions`
        public let path: String


    }
}

extension Paths.User.Packages.WithPackageType.WithPackageName.Versions {
    public func packageVersionID(_ packageVersionID: String) -> WithPackageVersionID {
        WithPackageVersionID(path: path + "/" + packageVersionID)
    }

    public struct WithPackageVersionID {
        /// Path: `/user/packages/{package_type}/{package_name}/versions/{package_version_id}`
        public let path: String

        /// Get a package version for the authenticated user
        public func get() -> Request<PackageVersion> {
            .get(path)
        }

        /// Delete a package version for the authenticated user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User.Packages.WithPackageType.WithPackageName.Versions.WithPackageVersionID {
    public var restore: Restore {
        Restore(path: path + "/restore")
    }

    public struct Restore {
        /// Path: `/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore`
        public let path: String


    }
}

extension Paths.User {
    public var projects: Projects {
        Projects(path: path + "/projects")
    }

    public struct Projects {
        /// Path: `/user/projects`
        public let path: String


    }
}

extension Paths.User {
    public var publicEmails: PublicEmails {
        PublicEmails(path: path + "/public_emails")
    }

    public struct PublicEmails {
        /// Path: `/user/public_emails`
        public let path: String


    }
}

extension Paths.User {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/user/repos`
        public let path: String


    }
}

extension Paths.User {
    public var repositoryInvitations: RepositoryInvitations {
        RepositoryInvitations(path: path + "/repository_invitations")
    }

    public struct RepositoryInvitations {
        /// Path: `/user/repository_invitations`
        public let path: String


    }
}

extension Paths.User.RepositoryInvitations {
    public func invitationID(_ invitationID: String) -> WithInvitationID {
        WithInvitationID(path: path + "/" + invitationID)
    }

    public struct WithInvitationID {
        /// Path: `/user/repository_invitations/{invitation_id}`
        public let path: String

        /// Decline a repository invitation
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var starred: Starred {
        Starred(path: path + "/starred")
    }

    public struct Starred {
        /// Path: `/user/starred`
        public let path: String


    }
}

extension Paths.User.Starred {
    public func owner(_ owner: String) -> WithOwner {
        WithOwner(path: path + "/" + owner)
    }

    public struct WithOwner {
        /// Path: `/user/starred/{owner}`
        public let path: String
    }
}

extension Paths.User.Starred.WithOwner {
    public func repo(_ repo: String) -> WithRepo {
        WithRepo(path: path + "/" + repo)
    }

    public struct WithRepo {
        /// Path: `/user/starred/{owner}/{repo}`
        public let path: String

        /// Check if a repository is starred by the authenticated user
        public func get() -> Request<Void> {
            .get(path)
        }

        /// Unstar a repository for the authenticated user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var subscriptions: Subscriptions {
        Subscriptions(path: path + "/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/user/subscriptions`
        public let path: String


    }
}

extension Paths.User {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/user/teams`
        public let path: String


    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/users")
    }

    public struct Users {
        /// Path: `/users`
        public let path: String


    }
}

extension Paths.Users {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: path + "/" + username)
    }

    public struct WithUsername {
        /// Path: `/users/{username}`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/users/{username}/events`
        public let path: String


    }
}

extension Paths.Users.WithUsername.Events {
    public var orgs: Orgs {
        Orgs(path: path + "/orgs")
    }

    public struct Orgs {
        /// Path: `/users/{username}/events/orgs`
        public let path: String
    }
}

extension Paths.Users.WithUsername.Events.Orgs {
    public func org(_ org: String) -> WithOrg {
        WithOrg(path: path + "/" + org)
    }

    public struct WithOrg {
        /// Path: `/users/{username}/events/orgs/{org}`
        public let path: String


    }
}

extension Paths.Users.WithUsername.Events {
    public var `public`: Public {
        Public(path: path + "/public")
    }

    public struct Public {
        /// Path: `/users/{username}/events/public`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/users/{username}/followers`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var following: Following {
        Following(path: path + "/following")
    }

    public struct Following {
        /// Path: `/users/{username}/following`
        public let path: String


    }
}

extension Paths.Users.WithUsername.Following {
    public func targetUser(_ targetUser: String) -> WithTargetUser {
        WithTargetUser(path: path + "/" + targetUser)
    }

    public struct WithTargetUser {
        /// Path: `/users/{username}/following/{target_user}`
        public let path: String

        /// Check if a user follows another user
        public func get() -> Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUsername {
    public var gists: Gists {
        Gists(path: path + "/gists")
    }

    public struct Gists {
        /// Path: `/users/{username}/gists`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var gpgKeys: GpgKeys {
        GpgKeys(path: path + "/gpg_keys")
    }

    public struct GpgKeys {
        /// Path: `/users/{username}/gpg_keys`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var hovercard: Hovercard {
        Hovercard(path: path + "/hovercard")
    }

    public struct Hovercard {
        /// Path: `/users/{username}/hovercard`
        public let path: String

        /// Get contextual information for a user
        public func get() -> Request<OctoKit.Hovercard> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUsername {
    public var installation: Installation {
        Installation(path: path + "/installation")
    }

    public struct Installation {
        /// Path: `/users/{username}/installation`
        public let path: String

        /// Get a user installation for the authenticated app
        public func get() -> Request<OctoKit.Installation> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUsername {
    public var keys: Keys {
        Keys(path: path + "/keys")
    }

    public struct Keys {
        /// Path: `/users/{username}/keys`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var orgs: Orgs {
        Orgs(path: path + "/orgs")
    }

    public struct Orgs {
        /// Path: `/users/{username}/orgs`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/users/{username}/packages`
        public let path: String


    }
}

extension Paths.Users.WithUsername.Packages {
    public func packageType(_ packageType: String) -> WithPackageType {
        WithPackageType(path: path + "/" + packageType)
    }

    public struct WithPackageType {
        /// Path: `/users/{username}/packages/{package_type}`
        public let path: String
    }
}

extension Paths.Users.WithUsername.Packages.WithPackageType {
    public func packageName(_ packageName: String) -> WithPackageName {
        WithPackageName(path: path + "/" + packageName)
    }

    public struct WithPackageName {
        /// Path: `/users/{username}/packages/{package_type}/{package_name}`
        public let path: String

        /// Get a package for a user
        public func get() -> Request<Package> {
            .get(path)
        }

        /// Delete a package for a user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUsername.Packages.WithPackageType.WithPackageName {
    public var restore: Restore {
        Restore(path: path + "/restore")
    }

    public struct Restore {
        /// Path: `/users/{username}/packages/{package_type}/{package_name}/restore`
        public let path: String


    }
}

extension Paths.Users.WithUsername.Packages.WithPackageType.WithPackageName {
    public var versions: Versions {
        Versions(path: path + "/versions")
    }

    public struct Versions {
        /// Path: `/users/{username}/packages/{package_type}/{package_name}/versions`
        public let path: String


    }
}

extension Paths.Users.WithUsername.Packages.WithPackageType.WithPackageName.Versions {
    public func packageVersionID(_ packageVersionID: String) -> WithPackageVersionID {
        WithPackageVersionID(path: path + "/" + packageVersionID)
    }

    public struct WithPackageVersionID {
        /// Path: `/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}`
        public let path: String

        /// Get a package version for a user
        public func get() -> Request<PackageVersion> {
            .get(path)
        }

        /// Delete package version for a user
        public func delete() -> Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUsername.Packages.WithPackageType.WithPackageName.Versions.WithPackageVersionID {
    public var restore: Restore {
        Restore(path: path + "/restore")
    }

    public struct Restore {
        /// Path: `/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var projects: Projects {
        Projects(path: path + "/projects")
    }

    public struct Projects {
        /// Path: `/users/{username}/projects`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var receivedEvents: ReceivedEvents {
        ReceivedEvents(path: path + "/received_events")
    }

    public struct ReceivedEvents {
        /// Path: `/users/{username}/received_events`
        public let path: String


    }
}

extension Paths.Users.WithUsername.ReceivedEvents {
    public var `public`: Public {
        Public(path: path + "/public")
    }

    public struct Public {
        /// Path: `/users/{username}/received_events/public`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/users/{username}/repos`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/users/{username}/settings`
        public let path: String
    }
}

extension Paths.Users.WithUsername.Settings {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/users/{username}/settings/billing`
        public let path: String
    }
}

extension Paths.Users.WithUsername.Settings.Billing {
    public var actions: Actions {
        Actions(path: path + "/actions")
    }

    public struct Actions {
        /// Path: `/users/{username}/settings/billing/actions`
        public let path: String

        /// Get GitHub Actions billing for a user
        public func get() -> Request<ActionsBillingUsage> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUsername.Settings.Billing {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/users/{username}/settings/billing/packages`
        public let path: String

        /// Get GitHub Packages billing for a user
        public func get() -> Request<PackagesBillingUsage> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUsername.Settings.Billing {
    public var sharedStorage: SharedStorage {
        SharedStorage(path: path + "/shared-storage")
    }

    public struct SharedStorage {
        /// Path: `/users/{username}/settings/billing/shared-storage`
        public let path: String

        /// Get shared storage billing for a user
        public func get() -> Request<CombinedBillingUsage> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUsername {
    public var starred: Starred {
        Starred(path: path + "/starred")
    }

    public struct Starred {
        /// Path: `/users/{username}/starred`
        public let path: String


    }
}

extension Paths.Users.WithUsername {
    public var subscriptions: Subscriptions {
        Subscriptions(path: path + "/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/users/{username}/subscriptions`
        public let path: String


    }
}

extension Paths {
    public static var zen: Zen {
        Zen(path: "/zen")
    }

    public struct Zen {
        /// Path: `/zen`
        public let path: String


    }
}

